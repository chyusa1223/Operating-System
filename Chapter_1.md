## 0. 서론 
운영체제란 컴퓨터 하드웨어를 관리하는 프로그램이다. 운영체제는 또한 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. 이러한 일들을 수행하기 위한 다양한 방법이 존재하며, 크게 편리성과 효율성의 조합으로 설계 되었다. 이 장에서는 현대 컴퓨터 시스템의 주요 구성요소와 운영체제가 제공하는 기능에 대한 일반적인 개관을 제공한다. 



## 1. 운영체제가 할 일
*   전체 컴퓨터 시스템에서 운영체제가 수행하는 역할에 대해 살펴보자. 컴퓨터 시스템은 크게 4가지 구성 요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다. 운영체제는 정부와 유사하여, 그 자체로는 유용한 기능을 수행하지 못한다. 그러나 컴퓨터 시스템이 동작할 때 이들 자원을 적절하게 분배하고 다양한 응용 프로그램간의 하드뒈어 사용을 제어 및 조절한다. 


## 1.1 사용자 관점
*   컴퓨터에 대한 사용자의 관점은 인터페이스에 따라 달라진다. 

### 1.1.1 개인 PC
*   모니터, 키보드, 마우스로 구성된 PC에서 작업을 수행한다. 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었다. 따라서 사용의 용이성에 중점을 두고 설계되고 성능에는 약간의 신경을 쓰고 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되는지에는 거의 신경을 쓰지 않는다. 

### 1.1.2 대형 컴퓨터 혹은 미니 컴퓨터에 연결된 터미널
*   다수의 사용자가 터미널을 통해 동일한 컴퓨터에 접근하고 있다. 이들 사용자들은 자원을 공유하며 정보를 교환할 수 있다. 이 경우 운영체제는 자원 이용을 극대화하도록 설계된다. CPU 시간, 메모리 및 입출력은 효율적으로 사용되며 각 개인 자신의 정당한 몫만 사용할 수 있다. 

### 1.1.3 워크스테이션 혹은 서버
*   사용자는 개인이 마음대로 사용할 수 있는 전용 자원을 갖지만 이들은 또한 네트워크, 서버-파일, 계산 및 프린터 서버를 공유한다. 따라서 운영체제는 개인의 사용 용이성과 자원 이용 간에 적절히 조화를 이루도록 설계되어 있다. 

### 1.1.4 휴대용 컴퓨터 
*   이들은 개인 사용자들을 위한 독립형 장치이며 전화망이나 무선 기술을 통해 네트워크에 연결된다. 휴대용 컴퓨터의 사용자 인터페이스는 터치 스크린을 사용하며, 이를 통해 사용자들은 키보드나 마우스 대신 손가락으로 스크린을 누르거나 밀어 시스템과 상호 작용한다. 

### 1.1.5 기타
*   가전제품 혹은 자동차 내의 내장형 컴퓨터의 경우 사용자 관점이 매우 작은 비중을 차지한다. 이와 같은 컴퓨터나 운영체제는 사용자의 개입없이 작동하도록 설계되어 있다. 


## 1.2 시스템 관점

### 1.2.1 자원 할당자
*   컴퓨터 시스템의 경우 문제를 해결하기 위해 요구되는 여러 가지 자원들 ( CPU시간, 메모리 공간, 파일 저장 공간, 입출력 장치)의 관리자로서 동작하며, 작업을 위해 특정 프로그램과 사용자에게 필요한 자원을 할당한다. 자원에 대한 서로 상충될 수 있는 요청이 있기 때문에, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지를 결정해야한다. 

### 1.2.2 제어 프로그램
*   컴퓨터의 부적절한 사용을 방지하기 위해서 사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊이 관여한다. 


## 1.3 운영체제의 간략한 역사 및 정의

*   운영체제가 존재하게 된 이유는 유용한 컴퓨터 시스템을 만드는 과정에서 발생하는 문제점을 해결하기 위한 적절한 방법이기 때문이다. 컴퓨터 시스템은 사용자의 프로그램을 실행하고, 사용자의 문제를 쉽게 해결해 주기위해 존재한다. 이러한 과정에서 컴퓨터 하드웨어가 제작되고, 순수 하드웨어 만으로는 사용하기 쉽지 않으므로 응용프로그램이 개발되었다. 이후 다양한 응용 프로그램들은 입출력 장치의 통제와 같은 공통적인 연산을 필요로 하게 된다. 여기에 자원을 제어하고 할당하는 공통 기능을 하나의 소프트웨어로 통합한 것이 오늘날의 운영체제이다.

*   초장기 컴퓨터는 암호 깨기와 탄도 계산과 같은 특수 목적 시스템으로 사용되었다. 그러나 이후 컴퓨터는 범용의 다기능 대형컴퓨터로 발전하였고 그즈음 운영체제가 탄생하게 되었다. 컴퓨터의 기능이 확대되고 크기는 작아졌으며, 용도가 다양해 졌고, 그에 맞춰 다양한 운영체제가 생겨났다. 이러한 다양한 운영체제에 대한 완벽한 정의는 존재하지 않는다. 다만 일반적인 정의로 운영체제는 컴퓨터에서 항상 수행되는 프로그램으로 일반적으로 커널이라 불린다. 그러나 오늘날 휴대용 장치의 운영체제를 보면 운영체제를 구성하는 기능의 수가 증가함을 볼 수 있다. 휴대용 운영체제는 종종 핵심 커널외에 미들웨어 ( 응용 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크 집합)을 포함한다. 예를 들어 IOS, 안드로이드는 핵심 커널과 더불어 데이터베이스, 멀티미디어 및 그래픽스를 제공한다.  



## 2. 컴퓨터 시스템의 구성 


## 2.1 컴퓨터 시스템 연산

### 2.1.1 컴퓨터 시스템 구조

*   컴퓨터 시스템은 CPU, 공유 메모리, 장치 제어기, 공통 버스로 구성되어 있다. CPU, 장치 제어기는 공유 메모리에 대한 접근을 제공하는 공통 버스에 의해 연결되어 있다 (하기 그림 참조).

> I/O Interface란 무엇인가?

> 입출력 인터페이스, 입출력 채널, 입출력 프로세서, 입출력 제어기, 장치 제어기등 다양한 이름으로 불린다. 
이러한 인터페이스가 필요한 이유는 주변 장치의 경우 데이터의 형식 및 전송 속도의 차이로 
중앙 처리 장치와 주기억장치와의 직접적인 통신이 불가능하기 때문이다.  

*   각 장치제어기는 특정 장치( 디스크 드라이브, 오디오 장치 등 )을 관리하고 있으며 메모리 사이클을 얻기 위해 CPU와 경쟁하며 병렬 수행된다. 메모리 제어기는 메모리에 대한 접근을 동기화 함으로써 공유 메모리에 대한 질서 있는 접근을 유지한다. 

*   ![현대의 컴퓨터 시스템](https://t1.daumcdn.net/cfile/tistory/2772A041535305A41B)

### 2.1.2 컴퓨터 시스템 구동 과정

*   컴퓨터가 구동을 시작하기 위해서는 수행할 초기 프로그램이 필요하며 이를 부트스트랩 프로그램이라 지칭한다. 부트스트랩 프로그램은 보통 펌웨어라고 알려져 있는 컴퓨터 내의 읽기 전용 메모리나 EEPROM에 저장된다. 이것은 CPU 레지스터로부터, 장치 제어기, 메모리 내용등을 포함한 시스템의 모든 면을 초기화한다. 또한 부트스트랩 프로그램에는 운영체제를 적재하는 방법 및 수행을 시작하는 방법이 포함되어 있다. 따라서 부트스트랩 프로그램은 최종적으로 운영체제의 커널을 찾아 메모리에 적재하게 된다. 

> EEPROM이란?

> EEPROM을 설명하기에 앞서 우선 ROM의 변천 과정에 대해서 알아보겠다. ROM은 Read-only memory의 줄임말로, 말 그대로 읽기만 가능한 메모리라는 뜻이다. 하지만 이건 아주 옛날 이야기고, 최근 생산되는 대부분의 ROM은 적어도 한번 이상은 정보를 수정 가능하게끔 되어있다.

> ROM이 처음 세상에 등장했을 때는 공장에서 제조될때 바로 데이터가 저장되어 고정된 채 생산되었다. 그랬기 때문에 후에 데이터를 변경하는 것이 불가능 했다. 여기서 한발자국 더 나아간 것이 PROM이다. PROM(Programmable ROM)은 이름에서 보다시피 '프로그래밍 가능한' 롬이다. 프로그래밍 가능하다는 것은 내부의 회로를 변경해서 데이터를 수정할 수 있다는 말이다. 그러나 내부의 퓨즈를 끊어서 정보를 저장하는 방식이기 때문에 한번 데이터를 설정하면 그 이후에는 변경하지 못한다. 

>이것을 보완해서 나온 것이 EPROM(Erasable PROM)이다. EPROM은 자외선을 이용해서 정보를 지우며, 여러번 썼다 지웠다 할 수 있다. EPROM을 다시 보완해서 나온 것이 오늘 살펴볼 EEPROM이다. 자외선을 이용해서 정보를 지워야 하는 EPROM과는 다르게 전기적으로 지웠다 썼다 할 수 있기 때문에 쓰는 속도가 매우 빠르고, 전용 롬라이터(롬을 기록할 수 있도록 해주는 장비)가 없어도 손쉽게 다룰 수 있다. 심지어 EEPROM을 RAM의 대용으로 사용하는 경우도 있다. 예를 들어 Atmega328같은 마이컴에는 내부에 약 1kb정도의 EEPROM이 있는데, RAM용량이 부족한 경우 RAM대용으로 상수나 자주 사용하지 않는 변수 등을 여기에 담아서 활용하기도 한다. 물론 RAM보다는 훨씬 느리므로 사용하는데 한계는 있다.

> 출처 : https://kcal2845.tistory.com/37

*   커널이 적재되고 수행이 시작되면 시스템과 사용자에게 서비스를 제공할 수 잇다. 일부 서비스는 커널이 아닌 시스템 프로그램에 의해 제공되며 이들은 부트 시에 메모리에 적재되어 커널이 수행되는 동안 계속 수행되는 시스템 프로세스나 시스템 디먼이 된다. 유닉스에서는 첫 시스템 프로세스가 "init"이며, INIT에 의해 다른 많은 디먼이 시작된다. 이 단계가 끝나면 시스템이 완전히 부트된 상태이며 시스템은 이벤트 발생을 대기하게 된다. 

### 2.1.3 인터럽트(Interrupt)와 시스템 호출(System Call)

*   이벤트가 발생하면 하드웨어나 소프트웨어로부터 발생한 인터럽트에 의해 신호가 보내진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. 소프트웨어는 시스템 콜을 통해 인터럽트를 발생시킬 수 있다. 
*   CPU에 인터럽트가 도착하면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이 실행된다. 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 중단 되었던 연산을 재개한다. 
*   위와 같은 전달을 처리하는 직선적인 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러를 호출한다. 그러나 인터럽트는 매우 빠르게 처리되어야 하고, 사용 가능한 인터럽트의 수가 미리 정의되어 있으므로, 일반적인 루틴 호출 대신 테이블을 통하여 간접적으로 인터럽트 루틴이 호출 될 수 있다. 이러한 테이블에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있으며, 하위 메모리에 저장된다. 이 경우 인터럽트가 요청되면, 인터럽트를 유발한 장치를 우한 인터럽트 서비스 루틴의 주소를 제공하기 위해, 이 주소의 배열 즉, 인터럽트 벡터가 인터럽트 요청과 함께 주어진 고유의 유일한 장치번호로 색인된다. 
*   인터럽트 구조는 중단된 명령의 주소를 반드시 저장해야 된다. 최근 운영체제는 시스템 스택에 복귀 주소를 저장하며, 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요가 있다면, 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다. 인터럽트를 수행하고, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작된다. 

> [Interrupt 참고자료](https://slidesplayer.org/slide/14981607/)

## 2.2 저장 장치 구조 
### 2.2.1 저장 장치의 동작 과정 
*   CPU는 명령어를 단지 메모리로부터 가져올 수 있으므로 프로그램을 수행하기 위해서는 반드시 프로그램이 메모리에 적재되어 있어야한다. 범용 컴퓨터는 대부분의 프로그램을 주 메모리라 불리는 재기록 가능한 메모리에서 가져 오며, 이는 DRAM이라 불리는 반도체 기술로 구현된다. 앞서 살펴 보았듯이 EPPROM의 경우 펌웨어를 저장하기 위한 용도로 주로 사용되며, 예들 들어 스마트폰은 공장에서 설치한 프로그램을 저장하기 위해 EPPROM을 사용한다.   
*   모든 형태의 메모리는 바이트의 배열을 제공한다. 그리고 각 바이트는 자신의 주소를 가지고 있으며 크게 적재와 저장이 가능하다. 적재 명령은 주 메모리로부터 CPU 내부의 레지스터로 한 바이트 혹은 워드를 옮기는 것이다. 반대로 저장명령은 CPU 레지스터의 내용을 주 메모리로 옮긴다. 
*   폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을 명령 레지스터에 저장한다. 이어서 명령을 해독하고, 이 과정에서 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 이 후 결과가 다시 메모리에 저장될 수 있다. 이상적으로는 프로그램과 데이터가 주 메모리에 영구히 존재하면 좋겠으나 이는 하기 서술할 2가지 이유 때문에 불가하다. 첫 번째로 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다. 두 번째로 주 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 장치이다. 따라서 대부분의 컴퓨터 시스템은 주 메모리의 확장으로 보조 저장 장치를 제공한다. 가장 일반적인 보조 저장 장치로는 프로그램과 데이터를 모두 저장할 수 있는 자기 디스크가 존재한다. 대부분의 프로그램은 메모리에 적재될 때까지 디스크에 저장된다. 

### 2.2.2 저장 장치의 종류 및 특징

*   앞서 기술된 주 메모리 및 자기디스크외에도 다양한 저장장치가 존재하며 이를 하기의 그림처럼 하나의 계층으로서 표시할 수 있다. 

![저장 장치 계층](https://3.bp.blogspot.com/-HJnfPCXn2hs/WLv8yzbggrI/AAAAAAAAAt0/tLiPFBO6cDQhqOa5k_8GaTIIx_iBq3SZACLcB/s1600/010_Memory1.png)

*  상위 계층으로 갈 수록 접근 시간을 단축되나, 가격이 비싸지고 비트 당 비용이 증가한다. 서로 다른 비용과 속도를 갖는 것 외에도 휘발성 혹은 비휘발성의 특징을 가진다. 상기 그림에서 반도체 디스크의 위의 저장 시스템은 휘발성이며, 반면 반도체 디스크 및 그 아래의 장치들은 비휘발성이다. 반도체 디스크의 경우 다수의 종류가 존재하나 일반적으로 자기 디스크보다 빠르며 비휘발성이다. 반도체 디스크의 예시 중 하나는 플래시 메모리이다. 플래시 메모리는 카메라 및 PDA등에 사용되고 있으며 점차 범용 컴퓨터의 저장장치로 영역을 확대하고 있다. 완전한 메모리 시스템의 설계를 위해서는 이러한 요인들 간의 균형을 맞추어야 한다. 즉, 필요한 만큼의 상위 계층의 저장장치를 사용하며, 가능한 많은 비휘발성 메모리를 제공해야한다. 두 구성요소간의 전송률 혹은 시간에 차이가 날 경우 캐시의 도입또한 고려되어야한다. 


## 2.3 입출력 구조 
*   #1에서 잠시 언급하였듯이, 현대의 컴퓨터 시스템은 공통 버스에 의해 연결된 여러 개의 장치 제어기와 CPU로 구성되어 있다. 각 장치 제어기가 특정 타입의 장치를 담당한다. 개별 장치제어기는 약간의 로컬 버퍼 저장 장치와 특수 목적용 레지스터 집합을 유지한다. 장치 제어기는 자신이 제어하는 주변 장치와 자신의 로컬 버퍼 저장 장치 사이의 데이터 전송을 담당한다. 이 때 장치 제어기에 따라 하나 이상의 장치가 부착 될 수 있다. 예를 들어 SCSI 제어기에는 7개 이상의 장치가 부착 될 수 있다. 통상적으로 운영체제는 각 장치 제어기 마다 디바이스 드라이버를 가지고 있으며, 디바이스 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분에게 일관된 인터페이스를 제공한다. 

### 2.3.1 입출력 장치의 동작 
*   입출력 연산을 시작하기 위해, 디바이스 드라이버는 장치 제어기의 적절한 리지스터에 필요한 값을 적재한다. 장치 제어기는 동작을 결정하기 위해 레지스터의 내용을 조사한다. 이후 제어기는 장치로 부터 자신의 로컬 버퍼로 데이터 전송을 시작한다. 일단 데이터의 전송이 완료되면, 장치 제어기는 자신이 연산을 완료했음을 인터럽트를 통해 디바이스 드라이버에게 알린다. 그러면 디바이스 드라이버는 제어를 운영체제에게 반환하고 상태에 따라 데이터 혹은 데이터에 대한 포인터를 같이 반환할 수 있다.
*   위와 같은 방식은 많은 양의 데이터를 전송하는 데에는 높은 오버헤드를 초래한다. 이 문제를 해결하기 위해 도입된 기법이 DMA(Direct Memory Access)장치가 사용된다. 장치에 대한 버퍼, 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입없이 메모리로부터 혹은 메모리로 데이터 블록을 전송한다. 한 바이트마다 인터럽트가 발생하는 것이 아닌 블록 전송이 완료될 때 인터럽트가 발생하게 된다. 따라서 CPU는 장치 제어기가 데이터를 전송하는 동안 다른 작업을 수행할 수 있다. 일부 시스템의 경우 버스 대신에 스위치 구조를 사용한다. 이 경우에는 공유 버스를 사용하기 위한 경쟁이 존재하지 않고, 다수의 구성요소가 서로 동시에 통신하는 것이 가능하다. 이 때 DMA의 사용은 더욱 효과적이다. 

![DMA](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F993AB04A5C8391F5237D04)

## 3. 컴퓨터 시스템 구조 
### 3.1 단일 처리기 시스템
단일 처리기 시스템은 사용자 프로세스의 명령어를 포함하여 범용 명령어 집합을 수행할 수 있는 하나의 주 CPU를 가진다. 또한 대부분의 시스템들은 특수 목적의 전용 처리기를 가지고 있다.이 전용 처리기는 디스크나 키보드 또는 그래픽 제어기와 같은 특정 장치 처리기의 형태이거나 메인프레임에서와 같이 시스템이 구성요소들 간의 데이터를 빠르게 전송할 수 있는 입출력 처리기와 같은 범용 처리기에 가까운 형태로 제공 될 수도 있다. 이러한 전용 처리기들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지 않는다. 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는 이 처리기들이 수행할 다음 태스크에 대한 정보를 보내고 처리기들의 상태를 감시한다. 예를 들어 디스크 제어기 마이크로프로세서는 주 CPU로 부터 연속된 요청을 받아들여 자기 고유의 디스크 큐와 스케쥴링 알고리즘을 구현한다. 이 배합은 CPU가 직접 디스크 스케쥴링을 진행해야 하는 오버헤드를 감소시킨다.상기에 기술한 전용 마이크로프로세서의 사용 여부에 관계 없이 범용 CPU의 개수에 의하여 단일 처리기 시스템 혹은 다중 처리기 시스템이 분류된다. 

### 3.2 다중 처리기 시스템
*   다중 처리기 시스템이란 매우 밀접한 통신을 하는 하나 이상의 처리기들을 가지며, 컴퓨터 버스, 클락 메모리와 주변 장치를 공유하는 시스템을 지칭한다. 다중 처리기 시스템은 크게 두 가지 형태를 가진다. 첫 번째는 비대칭적 다중 처리라 지칭되며, 주 처리기와 부 처리기가 존재한다. 주 처리기는 작업을 스케줄하고 종속 처리기에 작업을 할당한다. 부 처리기는 명령을 처리하거나 미리 정의된 태스크를 수행한다. 두 번째는 대칭적 다중 처리라 지칭되며, 가장 일반적인 다중 처리기 시스템이다. 대칭적 다중 처리 시스템에서는 각 처리기가 운영체제 내의 모든 작업을 동등하게 수행하게 된다. 하기 그림은 전형적인 대칭적 다중 처리( Symmertic multiprocessing )의 형태를 나타낸다. 그림에서 확인할 수 있듯이 각 처리기는 자신의 레지스터와 캐시를 가지만 메모리를 공유하는 형태를 가진다. 

![대칭적 다중 처리 구조](https://t1.daumcdn.net/cfile/tistory/2627103E5353067F2B)

*   대칭적 다중처리와 비대칭적 다중 처리의 차이점은 하드웨어나 소프트웨어의 결과 일 수 있다. 특수한 하드웨어가 다중처리기들을 차별화 할 수 있으며, 또는 한 개의 주 처리기와 다수의 종 처리기를 허용하도록 소프트웨어를 설계할 수 있다. 그에 대한 예로 Sun의 운영체제인 SunOS는 버전에 따라 대칭적 다중 처리와 비대칭적 다중 처리를 제공한다. 

*   다중 처리에서는 계산 능력을 높이기 위해 CPU를 추가할 수 있다. 만일 CPU가 통합된 메모리 제어기를 가졌다면, CPU를 추가하여 시스템에서 주소 지정 가능한 메모리의 양을 늘릴 수 있다. 어떻든 다중처리는 메모리 접근 모델을 균등 메모리 접근에서 비균등 메모리 접근으로 변경하게 만들 수 있다. NUMA의 경우 UMA와는 다르게 메모리에 접근하는 시간이 프로세서와 메모리의 상대적인 위치에 따라서 달라진다. 아래의 그림으로 설명을 추가하면 시스템에 CPU 소켓이 네 개 있고, 512GB의 메모리가 설치되어 잇다면 물리 주소 0 ~ 128GB까지의 메모리는 0번 소켓에, 128 ~ 256GB까지의 메모리는 1번 소켓의 지역메모리가 되는 방식이다. 각 소켓에서 지역 메모리에 접근할 때는 원격 메모리에 접근할 때보다 훨씬 빠르게 데이터를 읽고 쓸 수 있다. 하나의 CPU코어에 여러 개가 들어가 있는 경우에는 같은 지역 메모리를 사용하는 CPU 코어들을 묶어서 하나의 NUMA 노드로 관리한다. 8코어 4소켓의 경우에는 0 ~ 7번 코어에는 NUMA 노드 0번, 8 ~ 15번 코어는 NUMA 노드 1번과 같이 할당되게 된다. 

![Intel 네할렘 NUMA 구조](https://www.researchgate.net/profile/Raul_De_la_Cruz/publication/285393464/figure/fig3/AS:670015036612628@1536755441422/Diagram-of-a-dual-socket-configuration-with-Intel-Nehalem-EP.png)

*   최근의 CPU는 하나의 칩에 여러 개의 코어를 포함시키는 것이 일반적이다. 이러한 다중 처리기 시스템을 멀티코어라고 지칭한다. 이들은 단일 코어를 가진 여러 개의 칩보다 효율적이며, 이는 칩 내의 통신이 칩 사이의 통신보다 빠르기 때문이다. 또한 여러 개의 단일 칩에 비하여 전력을 훨씬 덜 소모한다. 3.3절에서 후술하겠지만, 멀티코어 시스템은 다중 처리기 시스템인 반면에 모든 다중 처리기 시스템이 멀티코어인것은 아니다. 하기 그림에서는 한 칩에 두 개의 코어를 가지는 멀티코어를 보인다. 이 설계에서는 각 코어 별로 레지스터와 캐시를 가지나, 다른 설계에서는 공유 캐시를 가지도록 설계 할 수 있다. 이러한 멀티코어는 캐시, 메모리 및 버스 경쟁과 같은 요소를 제외하면, 운영체제의 입장에서는 N개의 표준 처리기처럼 인식된다. 

![멀티코어 설계 예시](https://www.elektronik-kompendium.de/sites/com/bilder/12031711.gif)

*    이 외에 블레이드 서버가 존재한다. 이 블레이드 서버의 경우에는 다수의 처리기 보드 및 입출력 보드, 네트워킹 보드들이 하나의 새시안에 장착되는 형태를 가진다. 일반적인 다중처리기 시스템과의 차이는 각각의 보드가 독립적으로 부팅 될 수 있다는 점이다. 

*   멀티코어 시스템의 경우 크게 3가지 장점을 가진다. 첫 번째는 처리기의 수를 증가시킴으로써, 단위 시간동안 더 많은 일을 처리하도록 할 수 있다. 그러나 N개의 처리기가 있다고 해서 처리량이 N배가 되는 것은 아니며, 이는 다수의 처리기가 하나의 태스크를 처리하기 위해 협력할 경우 오버헤드가 발생하기 때문이다. 두 번째는 규모의 경제이다. 이는 다중 처리기가 하나의 전원 공급 장치, 저장 장치등을 공유하기 때문이다. 이는 각각의 시스템에 동일한 데이터의 복사본을 유지하게 하는 것보다 일반적으로 비용이 저렴하다. 세 번째는 신뢰성의 증기이다. 여러 처리기가 존재할 경우, 한 처리기가 고장나더라도 여분의 처리기가 계속해서 일을 처리할 수 있으며, 단지 수행속도만이 느려질 뿐이다. 이렇게 살아남은 하드웨어의 수준에 비례해 계속적인 서비스를 제공하는 능력을 우아한 퇴보라고 한다. 일부 시스템은 어느 한 구성요소의 고장에도 불구하고 동작을 계속할 수 있기 때문에 우아한 퇴보를 넘어 결함 허용이라고 불린다. 결함 허용 시스템은 오류를 탐지하고, 진단하고 가능하다면 교정할 수 있게 하는 기법이 필요하다. 
 
### 3.3 클러스터형 시스템
*   클러스터 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다는 점에서 1.3.2절에서 설명한 다중 처리기 시스템과 차이가 난다. 그러한 시스템은 약결합이라고 간주된다. 클러스터형에 대한 일반적인 정의는 존재하지 않는다. 그러나 일반적으로 저장 장치를 공유하고 근거리 통신망이나 InfiniBand와 같은 고속의 상호 연결망으로 연결될 경우 이를 클러스터형 컴퓨터라고 지칭한다. 

*   클러스터링은 통상 높은 가용성을 제공하기 위해 사용된다. 즉, 클러스터 내 하나의 컴퓨터가 고장나도 서비스는 계속 제공된다. 일반적으로 고가용성은 시스템에 중복 기능을 추가함으로써 얻어진다. 클러스터 소프트웨어 중 한 층이 클러스터 노드에서 실행된다. 각 노드는 하나 이상의 다른 노드들을 감시한다. 만약 감시받던 노드가 고장나면 감시하던 노드가 고장 난 노드의 저장 장치에 대한 소유권을 넘겨받고 그 노드에서 실행 중이던 응용 프로그램을 다시 시작한다. 사용자와 응용 프로그램의 클라이언트는 잠시 동안의 서비스 중단만을 경험하게 된다. 

*   클러스터링은 대칭 혹은 비대칭적으로 구성될 수 있다. 비대칭형에서는 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 긴급대기 모드를 유지한다. 이 긴급대기 모드에 있는 PC는 활성 서버들을 감시하는 작업만을 수행한다. 서버가 고장 난다면 긴급 대기 모드의 호스트가 활성 서버가 된다. 대칭형 클러스터링에서는 둘 이상의 호스트들이 응용 프로그램을 실행하고 서를 감시한다. 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 보다 효율적이다. 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행가능해야 한다. 

*   한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 고성능 계산환경을 제공하도록 사용될 수 있다. 이러한 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로 단일 처리기나 SMP 시스템 보다 훨씬 큰 계산 능력을 제공할 수 있다. 그렇지만 응용이 클러스터를 이용할 수 있도록 작성되어야 한다. 이는 병렬화라는 기법으로 프로그램을 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 포함한다. 전형적으로 이들은 각 계산 노드가 문제의 일부를 해결한 후 모든 노드의 결과가 결합되어 최종해답을 얻게된다. 

*   다른 형태의 클러스터로 병렬 클러스터와 WAN을 이용한 클러스터가 존재한다. 병렬 클러스터는 여러 호스트가 공유 저장 장치 상의 동일한 데이터를 접근할 수 있게 한다. 대부분의 운영체제가 여러 호스트에 의한 이러한 동시 접근을 지원하지 않으므로 병렬 클러스터는 특수 소프트웨어 버전과 특별히 발매된 응용에 의해 달성된다. 추가적으로 일부 클러스터의 경우 수 킬로미터 떨어진 클러스터 노드뿐만 아니라 한 클러스터 안에서 수십 개의 노드들을 지원한다. 이러한 개선은 후술할 스토리지 에러어 네트워크(SAN)에 의해 가능해졌다. SAN은 여러 호스트를 여러 스토리지 장치에 부착할 수 있게 한다. 만일 으용과 데이터가 SAN에 저장된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에서 수행되도록 으용을 배정할 수 있다. 

## 4. 운영체제의 구조 
*   대부분의 운영체제가 가지고 있는 공통적인 부분에 대하여 이 절에서 설명하기로 한다. 

*   운영체제의 가장 중요한 면 중의 하나는 다중 프로그램이다. 일반적으로 단일 사용자는 CPU 또는 입출력 장치를 바쁘게 유지할 수 없다. 다중 프로그래밍은 CPU가 수행할 작업을 항상 하나이상 가지도록 작업을 구성함으로써 CPU 이용률을 증가시킨다. 

*   이는 다음과 같이 진행된다. 운영체제는 여러 작업을 메모리에 적재하는데, 이는 디스크의 작업 풀로 부터 오게된다. 왜냐하면 메모리 내에 동시에 저장할 수 잇는 작업의 수는 통상 작업 풀에 둘 수 있는 작업의 수보다 훨씬 적기 때문이다. 작업 풀의 디스크 내의 모든 프로세스로 구성되며 이들은 주 메모리로의 할당을 대기하고 있다. 운영체제는 메모리에 적재된 작업 중 하나를 선택해게 실행한다. 결국 이 작업은 입출력의 종료를 기다리는 등과 같이 어떤 일을 기다려야 한다. 다중 프로그래밍 시스템에서는 운영체제가 단순히 다른 작업으로 전환해 그 작업을 수행한다. 이 나중의 작업이 어떤 일을 기다려야 한다면 다시 전환을 수행한다. 따라서 수행할 작업이 하나 이상 있는 한 CPU는 멈추지 않는다. 

*   다중 프로그래밍은 시스템은 여러 가지 시스템 자원을 효율적으로 이용할 수 있는 방법을 제공하지만 사용자를 위해 컴퓨터 시스템과 상호 작용은 제공하지 않는다. 시분할은 다중 프로그래밍의 논리적 확장이다. 시분할 시스템에서는 CPU가 다수의 작업들을 교대로 수행하지만, 매우 빈번하게 교대가 일어나기 때문에 프로그램이 실행되는 동안 사용자들은 각자 자기의 프로그램과 상호작용 할 수 있다. 

*   시분할 시스템은 사용자와 시스템 간에 직접적인 통신을 제공하는 대화식 컴퓨터 시스템을 필요로 한다. 시분할 운영체제는 동시에 많은 사용자가 컴퓨터를 공유하도록 한다. 시분할 시스템에서 각각의 동작이나 명령은 대체로 짧은 경향이 있기 때문에, 각 사용자는 단지 짧은 시간 동안만 CPU 시간이 필요하다. 시스템이 한 사용자에서 다른 사용자로 매우 빠르게 전환되기 때문에, 각 사용자들은 자신이 전체 컴퓨터를 사용하는 것처럼 체감하게 된다. 

*   시분할 운영체제는 위와 같은 기능을 위해 CPU 스케쥴링과 다중 프로그래밍을 사용한다. 각 사용자는 메모리에 최소한 하나의 독립된 프로그램을 가지고 있다. 메모리에 적재되어 있고, 실행되고 있는 프로그램을 일반적으로 프로세스라고 한다. 프로세스가 수행될 때는, 전형적으로 자신이 종료되거나 입출력을 수행할 필요가 있을 때까지 아주 짧은 시간 동안만 실행된다. 입출력은 대화식일 수 있다. 대화식으로 이루어질 경우 예를 들어 입력은 사용자의 타이핑 속도에 영향을 받으며, 사람에게는 빠른 속도 일지라도 컴퓨터의 입장에서는 매우 느린 것이다. 따라서 이러한 대화식 입력이 진행되는 동안 CPU를 쉬게 하지 않고, 운영체제는 CPU를 계속하여 전환시킨다. 

*   시분할과 다중 프로그래밍 운영체제에서는 여러 작업이 메모리에 동시에 유지되어야 한다. 만약 몇몇 작업이 메모리로 옮겨올 준비가 되었고, 그들 전부를 메모리에 보관할만한 공간이 불충분하다면, 시스템은 그들 중 몇 개를 선택해야 한다. 이러한 결정을 하는 것이 작업 스케쥴링이다. 운영체제가 작업 풀에서 하나의 작업을 선택하면, 실행을 위해 그 작업을 메모리에 적재한다. 메모리에 여러 개의 프로그램이 동시에 있을 때 어떠한 형태로는 메모리 관리가 필요하며, 이는 8,9장에서 추가적으로 다룬다. 또 여러 개의 작업이 동시에 실행 준비가 되어 이으면, 시스템은 그들 중 하나를 선택해야 한다. 이러한 결정을 내리는 것을 CPU 스케줄링 이라고 한다. 마지막으로, 병행적으로 수행되는 다수의 작업은 프로세스 스케줄링, 디스크 저장 장치, 그리고 메모리 관리를 포함하여, 운영체제 모든 단계에서 상호간에 영향을 미치는 능력이 제한 될 필요가 있다. 

*   시분할 시스템에서 운영체제는 적절한 응답시간을 보장해야한다. 이는 종종 스와핑에 의해 달성되는데, 스와핑은 프로세스를 주 메모리에서 디스크로 적절하게 스왑인 또는 스왑아웃 한다. 합리적인 응답시간을 보장하는 더 일반적인 방법은 가상메모리 인데, 이것은 일부만 메모리에 있는 작업의 수행을 허용하는 기법이다. 이 기법의 장점은 프로그램이 물리 메모리의 크기보다 커도 된다는 것이다. 더욱이 가상 메모리는 주 메모리를 크고 균등한 저장 장치의 배열로 추상화하여, 사용자에게 보이는 논리 메모리를 물리 메모리로 부터 분리 시킨다. 

*   시분할 시스템은 반드시 파일 시스템도 제공해야 한다. 파일 시스템은 다수의 디스크 상에 존재하므로, 디스크 관리 기법이 반드시 제공되어야 한다. 또한 시분할 시스템은 부적당한 사용으로 부터 자원을 보호하기 위한 기법을 제공해야 한다. 작업이 질서 정연하게 실행되도록 하기 위해, 시스템은 반드시 작업 동기화와 통신 기법을 제공해야 하며, 작업이 서로를 영원히 기다리는 교착 상태에 빠지지 않도록 히야한다. 
   	
## 5. 운영체제 연산

*   앞서 언급했던 것처럼, 현대의 운영체제는 인터럽트 구동식이다. 실행할 프로세스가 없고, 서비스할 입출력 장치도 없으면 운영체제는 무언가 할 일을 기다리며 있게된다.  그러나 사건은 항상 인터럽트나 트랩읇 발생시켜 신호를 보낸다. 트랩은 오류, 혹은 사용자 프로그램의 운영체제 서비스 수행 요청에 의해 유발되는 소프트웨어에 의해 생성된 인터럽트이다. 운영체제의 인터럽트 구동식 특성은 시스템의 일반적인 구조를 정의한다. 각 타입의 인터럽트에 대해 어떠한 행동을 취해야 할지는 운영체제 내의 서로 다른 코드 세그먼트가 결정한다. 

### 5.1 이중 연산 모드 

*   운영체제와 사용자는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에 사용자 프로그램의 오류가 현재 수행 중인 프로그램에만 문제를 일으키도록 보장해야한다. 공유 때문에 한 프로그램의 버그가 많은 프로그램에 악 영향을 미칠 것이다. 다중 프로그래밍에서는 조금 더 미묘한 오류가 발생할 수 있다. 하나의 잘못된 프로그램이 다른 프로그램 코드나 데이터 또는 운영체제 자체를 변경할 수 있다. 

*   이러한 종류의 오류에 대한 보호 기능이 없으면 컴퓨터 시스템은 한 순간에 단 하나의 프로세스만을 수행시키거나 또는 모든 출력 결과를 의심할 수 밖에 없다. 올바르게 설계된 운영체제는 잘못된 또는  악의적인 프로그램이 다른 프로그램이 부정확하게 수행되지 않도록 보장해야 한다.     

*   운영체제의 적절한 동작을 보장하기 위해, 운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분 할 수 있어야 한다. 많은 운영체제에 의해 취해지는 접근 방법은 우리가 여러 실행모드를 구분할 수 있도록 하드웨어 지원을 제공하는 것이다. 즉, 적어도 두 개의 독립된 연산모드, 사용자모드와 커널모드( Superviser, System, Privileged mode)를 필요로 한다. 모드 비트라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다. 이 비트는 커널모드(0) 또는 사용자 모드(1)를 나타낸다. 모드 비트의 사용으로, 우리는 운영체제를 위하여 실행되는 작업과 사용자를 위해서 실행되는 작업을 구분할 수 있다. 즉, 사용자가 프로그램을 실행시키면 사용자 모드에서 동작을 수행하게 된다. 이후 사용자의 응용 프로그램이 시스템 호출을 하게 되면 이때 이 요청을 수행하기 위해 사용자모드에서 커널모드로 전환하게 된다. 하기 그림에 이 절차를 표현하고 있다. 

*   ![사용자 모드에서 커널 모드로의 전환](https://t1.daumcdn.net/cfile/tistory/2214F1445355730538)

*   예를 들어, 부팅 과정에서 모드 전환은 다음과 같이 이루어진다. 최초 시스템 부트 시, 하드웨어는 커널 모드에서 시작한다. 트랩이나 인터럽트가 발생할 때마다, 하드웨어는 사용자 모드에서 커널 모드로 전환한다. 그러므로 운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 된다. 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 전환하게 된다. 

*   이러한 동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 잘못된 사용자 서로를 보호하는 방법을 우리에게 제공한다. 우리는 악영향을 끼칠 수 있는 일부 명령을 특권 명령으로 지정함으로써 이러한 보호를 달성한다. 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다. 사용자 모드에서 특권 명령을 수행하려고 시도할 경우, 하드웨어는 이를 실행하지 않고, 불법적인 명령으로 간주해 운영체제로 트랩을 건다. 특권 명령의 예로는 커널 모드로의 전환, 입출력 제어, 타이머 관리 그리고 인터럽트 관리를 위한 명령어등이 포함된다. 

*   > [커널모드가 안전한 이유](https://kldp.org/node/151632)

*   위에서의 모드 개념은 두 개 이상의 모드로 확장 될 수 있다. 물론 이러한 경우에 CPU는 한 비트 이상을 모드를 위해 제공해야 한다. 가상화를 지원하는 CPU는 시스템을 가상 기계 관리자가 제어하고 있는지를 나타내기 위해 종종 별도의 모드 비트를 사용한다. 이 모드에서는 VMM이 커널모다는 작지만 사용자 프로세스보다는 큰 권한을 가지게 된다. VMM은 가상기계를 생성하고 관리하며 CPU 상태를 변경하기 위해 이러한 수준의 특권을 필요로 한다. 때로는 여러 커널 구성요소들이 다른 모드를 사용하기도 한다. 예를 들어 인텔 64계열의 CPU는 4개의 특권 수준을 지원하며, 가상화 또한 지원하지만 가상화를 위한 별도의 모드는 존재하지 않는다. 

*   시스템 호출은 사용자 프로그램이 자신을 대신 하여 운영체제가 수행하도록 지정되어 있는 작업들을 운영체제에게 요청할 수 있는 방법이다. 시스템 호출은 컴퓨터 시스템이 지원하는 방법에 따라 다양한 방법으로 호출 될 수 있다. 시스템 호출은 일반적으로 인터럽트 벡터의 특정 위치로 트랩을 거는 형태를 취한다. 이 트랩은 보통 trap 명령어를 통해 수행되지만(예를 들면 MIPS) 몇몇 시스템은 syscall이라는 특정 명령어를 가지기도 한다. 

*   시스템 호출이 수행될 때, 시스템 호출은 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다. 제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다. 시스템 호출 서비스 루틴은 운영체제의 일부이다. 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 호출이 발생했는지를 결정한다. 이 때 전달 된 인수가 사용자 프로그램이 요청하는 서비스 타입을 표시한다. 요청이 필요로 하는 추가의 정보는 레지스터, 스택 또는 메모리로(이 때는 메모리 위치에 대한 포인터가 레지스터에 전달된다) 전달 된다. 커널은 인수가 정확한지 검증하고 요청을 수행한 후 제어를 시스템 호출 다음의 명령으로 복귀한다. 

*   하드웨어가 이중 모드를 지원하지 않을 경우 매우 심각현 결함을 초래할 수 있으며, 그 대표적인 예가 MS-DOS이다. MS-DOS는 모드 비트가 없는 Intel 8088을 위해 작성되ㅏ었다. 그러므로 잘못된 사용자 프로그램이 데이터를 운영체제 부분에 덮어 기록함으로써 운영체제를 지워버릴 수 있고, 또한 여러 프로그램이 동시에 한 장치에 기록할 수 있으며, 그 경우 불행한 결과가 발생할 수 있다.

*   하드웨어 보호 기능이 제공되면 모드 규칙을 ㅇ뤼반하는 오류가 하드웨어에 의해 탐지된다. 이러한 오류는 일반적으로 운영체제가 처리한다. 사용자 프로그램이 불법 적인 명령을 수행하려 하거나 사용자 주소 공간이 아닌 메로리에 접근을 시도하는 등과 같은 오류가 발생하면, 하드웨어는 운영체제로 트랩을 발생시킨다. 트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에 넘긴다. 프로그램 오류가 발생할 때마다, 운영체제는 비정상적으로 프로그램을 종료시킨다. 이것은 사용자가 요청한 비정상적인 종료와 동일한 코드에 의해 처리된다. 적절한 오류 메시지가 주어지며, 프로그램의 메모리가 덤프된다. 메모리 덤프는 사용자나 프로그래머가 이를 조사하고, 프로그램을 수정하여 다시 실행시킬 수 있도록 통상 파일에 기록된다. 

### 5.2 타이머 
*   우리는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장해야 한다. 우리는 사용자 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지 않는 경우가 없도록 반드시 방지해야 한다. 이러한 목적을 달성하기 위해, 타이머를 사용할 수 있다. 타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정 할 수 있다. 가변 타이머는 일반적으로 고정률의 클락과 계수기로 구현한다. 운영체제는 계수기 값을 설정한다. 클락이 tick할 때마다 계수기가 감소한다. 계수기가 0이 될 때 인터럽트가 발생한다. 사용자에게 제어를 양도하기 전에, 운영체제는 타이머가 인터럽트를 할 수 있도록 설정 되었는지를 확인한다. 만약 타이머가 인터럽트를 발생하면, 제어는 자동적으로 운영체제에 넘어가며 운영체제는 인터럽트를 치명적인 오류로 취급하거나, 또는 프로그램에게 더 많은 시간을 줄 수 있다. 타이머의 값을 변경하는 명령은 특권 명령에 해당한다. 

## 6. 프로세스 관리
*   현재까지의 내용에서 프로세스는 하나의 작업이나 하나의 시분할 프로그램으로 생각 될 수 있으나, 프로세스는 보다 일반적인 개념을 지칭한다. 예를 들어 프로세스가 병행 수행하기 위해 서브 프로세스를 생성하도록 허용하는 시스템 호출을 제공할 수 있다. 

*   프로세스는 자신의 일을 수행하기 위하여 CPU시간, 메모리, 파일, 그리고 입출력 장치를 포함한 여러가지 자원을 필요로 한다. 이러한 자원은 프로세스가 시작할 때 제공될 수도 있지만, 실행 되는 동안에 할당 될 수도 있다. 프로세스가 생성될 때 제공되는 여러 가지 자원들 외에 여러 초기화 데이터 또한 제공 될 수 있다. 

*   여기서 한 가지 주의해야 할 점은 프로그램 그 자체는 프로세스가 아니라는 점이다. 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적 존재인 반면, 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터를 가진 능동적 존재이다. 한 프로세스의 수행은 반드시 순차적이어야 하며 CPU는 그 프로세스가 끝날때까지 그 프로세스의 명령들을 차례대로 수행한다. 다중 스레드 프로세스는 복수개의 프로그램 카운터를 가지고 있으며 이 카운터들은 각 스레드가 실행할 다음 명령어를 가리키게 된다. 

*   한 프로세스는 한 시스템 내의 작업의 단위이며, 이러한 프로세스의 집합이 바로 시스템이 된다. 프로세스 중 일부는 운영체제 프로세스들이며 나머지는 사용자 프로세스들이다. 이들 모든 프로세스는 그들 간의 하나의 CPU를 멀티플랙싱함으로써 병행 수행될 수 있다. 

*   운영체제는 프로세스 관리와 연관되어 다음과 같은 활동에 대한 책임을 진다. 

>   1. CPU에 프로세스와 스레드를 스케줄 하기
>   2. 사용자 프로세스와 시스템 프로세스의 생성과 제거 
>   3. 프로세스의 일시 중지와 재수행 
>   4. 프로세스 동기화를 위한 기법 제공
>   5. 프로세스 통신을 위한 기법 제공 

## 7. 메모리 관리
*   폰 노이만 방식의 컴퓨터에서는 중앙 처리기가 명령어 인출 주기(Instruction fetch-cycle) 동안 주 메모리로부터 명령어를 읽고, 자료 인출 주기(Data fetch-cycle) 동안 주 메모리로부터 데이터를 읽고 또한 쓴다. 앞에서 설명한  대로 주 메모리는 일반적으로 CPU가 직접 주소를 지정할 수 있고, 그리고 직접 접근할 수 있는 유일한 대용량 저장장치이다. 

*   프로그램이 수행되기 위해서는 반드시 절대 주소로 매핑되고 메모리에 적재 되어야 한다. 프로그램을 수행하면서, 이러한 절대 주소를 생성하여 메모리의 프로그램 명령어와 데이터에 접근한다. 결국 프로그램이 종료되고, 프로그램이 차지하던 메모리 공간은 가용공간으로 선언되고, 다음 프로그램이 적재되어 수행될 수 있다. 

*   CPU 이용률과 사용자에 대한 컴퓨터의 응답속도를 개선하기 위해 우리는 메모리에 여러 개의 프로그램을 유지해야 하며 이를 위해서 메모리 관리 기법이 필요하다. 이러한 메모리 관리 기법에는 여러 종류가 있으며, 이러한 기법의 효율성은 특정 상황에 따라 다르다. 특정 시스템에 대한 메모리 관리 기법은 선택은 여러 요인에 의해 결정되지만, 특히 시스템의 하드웨어 설계에 좌우된다. 

*   운영체제는 메모리 관리와 관련하여 다음과 같은 일을 담당한다. 

>   1. 메모리의 어느 부분이 현재 사용되고 있으며 누구에 의해 사용되고 있는지를 추적해야 한다. 
>   2. 어떤 프로세스들을 메모리에 적재하고 제거할 것인가를 결정해야 한다. 
>   3. 필요에 따라 메모리 공간을 할당하고 회수해야 한다. 

## 8. 저장장치 관리

*   컴퓨터 시스템의 편리한 사용을 위해, 운영체제는 정보 저장 장치에 대한 균등한 논리적 관점을 제공한다. 운영체제는 저장 장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 파일을 정의한다. 운영체제는 파일을 물리적 매체로 맵하며, 저장 장치를 통해 이들 파일에 접근한다. 

### 8.1 파일 시스템 관리

*   파일 관리는 운영체제 구성요소 중 하나이다. 컴퓨터는 여러 타입의 물리적 매체에 정보를 저장할 수 있다. 자기 디스크, 광 디스크, 자기 테이프 등이 가장 일반적인 매체이다. 각 매체들은 자신의 특성과 물리적 구성을 가지고 있으며, 다스크 드라이브와 같은 장치에 의해 제어된다. 또한 이들 장치 별로 독특한 특성을 가지고 있다( 접근 속도, 용량, 데이터 전송률, 순차 접근, 임의 접근 ).

*   파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다. 일반적으로 파일은 프로그램( 소스와 목적프로그램 형태)과 데이터를 나타낸다. 데이터 파일은 숫자 및 문자로 구성된다. 파일은 텍스트 파일과 같은 자유 형태일 수도 있고, 엄격하게 포맷된 형태일 수도 있다. 명백히 파일의 개념은 지극히 일반적이다. 운영체제는 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다. 또한, 다수의 사용자가 파일에 접근하려고 할 때는 누구에 의해서, 그리고 어떤 방법으로 파일이 접근 되어야 하는가를 통제하게 된다. 

*   운영체제는 파일 관리를 위하여 다음과 같은 일을 담당한다. 

>   1. 파일의 생성 및 제거
>   2. 디렉토리 생성 및 제거
>   3. 파일과 디렉토리를 조작하기 위한 프리미티브의 제공 
>   4. 파일을 보조 저장 장치로 맵핑
>   5. 안정적인 저장 매체에 파일을 백업

### 8.2 대용량 저장장치 관리

*   현대의 컴퓨터 시스템은 디스크를 프로그램과 데이터를 위한 주된 온라인 저장 매체로 사용하고 있다. 컴파일러, 어셈블러, 워드 프로세서 등의 대부분의 프로그램은 우선 디스크에 저장되고, 후에 메모리에 적재된다. 따라서 디스크와 같은 대용량 저장장치의 관리는 컴퓨터 시스템에서 매우 중요한 부분을 자치한다. 

*   운영체제는 디스크 관리를 위하여 다음과 같은 기능을 담당한다. 

>   1. 자유 공간의 관리
>   2. 저장 장소 할당
>   3. 디스크 스케쥴링 

*   보조 저장 장치는 매우 빈번하게 사용되므로, 효율적인 사용이 요구된다. 컴퓨터의 전체 동작 속도는 디스크 서브시스템과 그것을 조작하는 알고리즘 속도에 의해 결정 될 수 있다. 그러나 디스크 데이터의 백업, 가끔 사용되는 데이터 및 장기간 보존을 위한 3차 저장 장치 또한 필요하다. 이러한 장치들은 시스템 성능에는 중요하지 않지만 운영체제에 의해 관리되어야만 한다. 

*   어떤 운영체제는 이 역할을 직접 수행하지만, 다른 운영체제는 이 역할을 응용 프로그램에게 맡기기도 한다. 운영체제가 제공해야 할 기능에는 마운트, 언마운트, 프로세스의 배타적 사용을 위한 장치의 할당과 변환, 그리고 보조 저장 장치로부터 3차 저장 장치로의 데이터 이주 등이 포함된다. 

### 8.3 캐싱
*   캐싱은 컴퓨터 시스템의 중요한 원리이다. 정보는 통상 어떤 저장 장치에 보관된다. 정보가 사용됨에 따라, 보다 빠른 장치인 캐시에 일시적으로 복사된다. 그러므로 우리가 특정 정보가 필요할 경우, 우리는 먼저 캐시에 그 정보가 있는지를 조사해 보아야 한다. 만약 캐시에 있으면, 우리는 그 정보를 캐시로부터 직접 사용하지만, 만일 캐시에 없다면 주 메모리 시스템으로부터 그 정보를 가져와서 사용해야 하며, 이 때 이 정보가 다음에 곧 다시 사용될 확률이 높다는 가정 하에 캐시에 넣는다. 
*   이에 덧붙여, 인덱스 레지스터와 같은 CPU 내부의 프로그램 가능한 레지스터들은 주 메모리를 위한 고속의 캐시로 볼 수 있다. 프로그래머는 어느 정보를 주 메모리에 두고, 어느 정보를 레지스터에 둘 것인지를 결정하는 레지스터 할당 정책과 교체 알고리즘을 구현한다. 추가적으로 전적으로 하드웨어로 구현된 명령 캐시등이 있지만 이는 운영체제로 제어할 수 없으므로 우리의 관심사가 아니다. 

*   캐시의 크기에 한계가 있으므로, 캐시 관리가 설계의 중요한 문제가 된다. 캐시의 크기와 교체 정책에 따라, 모든 접근에 80% ~ 99%를 캐시에서 얻을 수 있어 극도로 높은 성능을 얻게 된다. 캐시가 필요한 이유는 아래 그림의 대형 워크스테이션과 소형 서버에서의 저장 장치 성능을 보면 알 수 있다. 

![저장 장치 각 단계의 성능](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_11_StoragePerformance.jpg)

*   저장 장치의 계층 구조에서 각 수준간의 정보 이동은 하드웨어 설계나 제어하는 운영체제에 따라 명시적 또는 묵시적으로 이루어진다. 예를 들어 캐시로부터 CPU 및 레지스터로의 데이터 전송은 통상 운영체제의 간섭 없이 하드웨어적으로 이루어진다. 반면 디스크와 메모리 간의 데이터 전송은 통상 운영체제에 의해 제어된다. 

*   메모리의 계층 구조에서, 동일한 데이터가 서로 다른 수준의 저장 장치 시스템에 나타나게 된다. 예를 들어 B라는 파일에 있는 A라는 변수가 1 증가되어야 한다고 생각해 보자. 파일 B가 자기 디스크에 있다고 가정해 보자. 증가 연산은 먼저 A가 있는 디스크 블록을 주 메모리로 복사해오는 입출력 연산을 호출함으로써 진행된다. 이어서 A를 캐시에 복사하고, 이어 A를 다시 내부 레지스터로 복사한다. 따라서 A의 복사본이 여러 곳에 존재하게 된다. 내부 레지스터에서 증가가 일어날 경우, A의 값은 여러 저장 장치 시스템에서 서로 달라진다. A의 값은 자기 디스크의 새로운 A의 값이 다시 기록된 후에야 비로소 동일해진다. 

*   어떤 시간에 단지 하나의 프로세스만 실행하는 환경에서는 이러한 기법이 아무런 문제를 일으키지 않는다. 그러나 CPU가 여러 개의 프로세스들 사이에서 전환되는 경우에는 여러 개의 프로세스가 A에 접근하려고 할 때, 이들 각 프로세스가 가장 최근에 갱신된 A의 값을 얻을 것을 보장하는 극도의 조심이 필요하다. 

![정수 A를 디스크로부터 레지스터로 이동하는 과정](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_12_IntegerMigration.jpg)

*   CPU가 내부 레지스터를 유지할 뿐만 아니라 로컬 캐시도 갖고 있는 다중 처리기 환경 하에서는 상황이 더욱 복잡해 진다. 이런 환경에서는, A의 복사본이 동시에 여러 캐시에 존재할 수 있다. 여러 개의 CPU가 모두 동시에 실행 될 수 있으므로, 한 캐시에 있는 A값이 갱신 될 경우에 그것은 A가 존재하는 모든 캐시에 즉각적으로 반영되어야 한다. 이러한 상황을 캐시 일관성 문제라고 하며, 이는 일반적으로 하드웨어적인 문제로 간주한다. 

### 8.4 입출력 시스템 ( I/O System ) 
*   운영체제의 목적 중 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다. 예를 들면 UNIX에서 입출력 장치의 특성은 입출력 서브시스템에 의해 운영체제 자체의 대부분으로부터 숨겨져 있다. 

*   입출력 시스템의 구성 
>   1. 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성 요소 
>   2. 일반적인 장치 드라이버 인터페이스
>   3. 특정 하드웨어 장치들을 위한 드라이버 

*   단지 장치 드라이버만이 자신에게 지정된 특정 장치의 특성을 알고 있다. 

## 9. 보호와 보안
*   만일 컴퓨터 시스템이 다수의 사용자를 가지며, 다수의 프로세스의 명령 수행을 허용한다면, 데이터에 대한 접근은 반드시 규제되어야 한다. 이를 위해 파일, 메모리 세그먼트, CPU 및 다른 자원들에 대해 운영체제로 부터 적절한 허가를 획득한 프로세스만이 작업할 수 있도록 보장하는 기법이 필요하다. 예를 들면 메모리 주소 지정 하드웨어는 프로세스가 자신의 주소 영역에서만 실행될 수 있도록 보장한다. 타이머는 모든 프로세스가 CPU의 제어를 얻은 후 결국에는 제어를 양도하도록 보장한다. 여러 주변 장치의 무결성이 보호받도록, 장치 제어 레지스터들에 사용자가 접근할 수 없게 한다. 

*   보호란 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 또는 사용자들의 접근을 제어하는 기법이다. 이 기법은 시행될 제어에 대한 명세와 이들을 강제 시행하기 위한 방법을 규정하는 수단을 반드시 제공해야 한다. 보호는 구성 요소 서브시스템 간의 인터페이스에서 잠재적인 오류를 검출 함으로써 시스템의 신뢰성을 증가 시킬 수 있다. 인터페이스 오류를 초기에 발견하면 종종 고장난 서브시스템에 의해 정상적인 서브시스템이 오염되는 것을 방지할 수 있다. 보호되지 않은 자원은 권한이 없거나 또는 무자격 사용자에 의해 사용되는 것을 방지할 수 없다. 보호 지향 시스템은 허가받은 사용과 그렇지 않은 사용을 구별하는 방법을 제공한다. 

*   컴퓨터 시스템은 충분한 보호기능을 가지고 있더라도 여전히 고장이 나거나 부적절한 접근을 허용할 수 있다. 예를 들어 사용자의 인증 정보가 도난 당한 경우 보호 기능이 있어도 데이터의 접근, 복사, 도용등을 피할 수는 없다. 이처럼 바이러스, 웜, DDOS, 식별자 도용, 서비스 도용 등 많은 공격방법이 존재한다.

*    보호와 보안을 제공하기 위해서 시스템의 모든 사용자들을 구분할 수 있어야 한다. 대부분의 운영체제들은 사용자 이름과 연관된 사용자 식별자의 리슽으를 유지한다. Windows 용어로는 보안 식별자라고 지칭한다. 이 식별자는 사용자마다 할당되고 시스템에서 유일한 값을 가진다. 사용자가 로그인 할 때 인증 단계에서 사용자에 맞는 적절한 식별자를 결정한다. 이 사용자 식별자는 사용자의 모든 프로세스나 스레드에 연관된다.

*   어떤 상황에서는 각 사용자가 아니라 사용자의 집합을 구분하기를 원한다. 예를 들면 UNIX 시스템에서는 파일 소유주에게는 모든 연산을 허용하고 일부 사용자들에게는 읽기 연산만을 허용할 수 있다. 이를 위하여 그룹 이름과 그 그룸에 속한 사용자들을 정의할 필요가 있다. 그룹 기능은 시스템 전체에 존재하는 그룹 이름과 그룹 식별자의 리스트로 구현 될 수 있다. 사용자는 운영체제 설계시 결정에 따라 하나 이상의 그룹에 속할 수 있다. 사용자의 그룹 식별자는 역시 관련된 모든 프로세스나 스레드에 연관 된다. 

*   시스템을 정상적으로 사용하는 동안 사용자 식별자와 그룹 식별자만 있으면 충분하다. 그러나 사용자는 때때로 원하는 작업을 수행하기 위하여 권한을 상승해야 할 경우도 존재한다. 예를 들어 사용자가 제한된 장치를 접근해야 할 때도 있다. 운영체제는 권한 상승을 허용하는 다양한 방법을 제공한다. 예를 들면 UNIX에서는 프로그램이 수행될 때 setuid 속성을 이용하여 현 사용자의 식별자가 아니라 접근하려고 하는 파일의 소유주 식별자를 이용하여 동작 할 수 있다. 프로세스는 종료되거나 특권을 해제하기 전까지 이 유효 사용자 식별자를 이용하여 수행된다.          

## 10. 커널 자료구조 
*   생략 

## 11. 계산환경
* 이 장은 아래의 내용 가볍게 한 번만 읽고 넘어갈 것.

### 11.1 전통적 계산 

*   계산이 성숙해 짐에 따라 여러 전통적인 계산 환경의 경계가 흐려지고 있다. 전형적인 사무실 환경을 고려해 보자. 몇 년 전만 해도 이 환경은 네트워크에 연겨로딘 PC들과 파일과 프린트 서비스를 제공하는 서버들로 구성되었다. 원격 접근은 흔하지 않았으며 이동성은 랩탑을 사용함으로써 이루어졌다. 여러 회사에서는 대형 컴퓨터에 연결된 터미널도 널리 사용되었으며, 이 경우 원격 접근과 이동성이 훨씬 더 작았다. 

*   현재의 추세는 이러한 원격 접근과 이동성을 다양하게 제공하려 한다. 웹 기술이 전통적인 계산의 경계를 확장시키고 있다. 회사들은 자신의 내부 서버에 웹 접근을 제공하는 포털을 구현하고 있다. 네트워크 컴퓨터는 실질적으로 웹 기반 컴퓨팅을 이해하는 터미널을 말하며 이들은 보다 높은 보안이나 쉬운 보수가 필요한 경우 전통적 워크스테이션을 대체하여 사용되고 있다. 휴대용 컴퓨터는 PC와 동기화하여 회사 정보를 쉽게 휴대할 수 있게 한다. 휴대용 컴퓨터는 또한 무선 네트워크나 이동전화 망에 연결되어 회사의 웹 포탈을 사용할 수 있게 한다. 

*   집에서 대부분의 사용자는 하나의 컴퓨터가 느린 모뎀 연결을 통해 사무실이나 인터넷 또는 양쪽 모두에 연결되어 있었다. 한 때는 큰 비용이 들었던 네트워크 연결 속도는 싼 비용으로 이용 가능하며, 더 많은 데이터에 더 많은 접근을 가능하게 한다. 이러한 고속 연결은 홈 컴퓨터가 웹 페이지를 제공하고 프린터, 클라이언트 PC, 그리고 서버를 갖는 자신의 네트워크를 가질 수 있게 한다. 일부 홈은 이러한 홈 계산 환경을 보안 침해로부터 보호하기 위해 방화벽을 가지고 있다. 

*   20세기 후반에는 계산 자원이 귀했다. 한동안 시스템은 배치 또는 대화형 방식이었다. 배치 시스템은 파일이나 다른 데이터 소스로부터 미리 정해진 입력을 가지고 대량으로 작업을 처리하였다. 대화형 방식 시스템은 사용자로부터 입력을 기다렸다. 계산 자원을 최적으로 사용하기 위하여 다중 사용자들이 이 시스템을 시간을 나누어 사용하였다. 시분할 시스템은 자원의 일정량을 각 사용자에게 프로세스를 CPU에 하나씩 순환시켜 가면서 실행시키기 위하여 타이머와 스케줄링 알고리즘을 이용하였다. 

*   오늘날 전통적 시분할 시스템은 흔하지 않다. 동일한 스케줄링 기법이 워크스테이션과 서버에서 사용되고 있다. 그러나 모든 프로세스는 한 사용자가 전부 소유하거나 또는 단일 사용자와 운영체제가 소유하고 있는 형태를 취한다. 사용자 프로세스와 사용자에게 서비스를 제공하는 시스템 프로세스는 계산 시간을 빈번하게 얻을 수 있도록 관리한다. 예를 들어 PC 상에서 작업하는ㄷ ㅗㅇ안 생성된, 동시에 다른 태스크를 수행할 수 있는 윈도들을 생각하라. 하나의 웹 브라우저 조차도 현재 방문하는 각 웹 사이트 별로 한 프로세스를 갖도록 다수의 프로세스로 구성될 수 있으며 각 웹 브라우저들에 시분할이 적용된다. 
 
### 11.2 이동형 컴퓨팅

*   이동형 계산은 휴대용 스마트폰과 태블릿 컴퓨터의 계산을 말한다. 이들 장치들은 이동가능하고 가볍다는 물리적 특징을 공유한다. 역사적으로 데스크톱이나 랩톱과 비교하면 휴대용 시스템은 화면 크기, 메모리 용량과 전체적 기능을 포기한 대신 이메일과 같은 특수한 서비스를 손에 쥘 수 있는 휴대용 접근을 얻은 것이다. 그렇지만 지난 몇 년 동안 휴대용 장치의 기능이 풍부해져서 이를테면 소비자용 랩톱과 태블릿 컴퓨터 사이의 기능 구분이 분명하지 않게 되었다. 실제 최신 휴대용 장치는 데스크톱이나 랩톱 컴퓨터에 없거나 실용성이 떨어졌던 기능조차 허용한다고 주장할 수도 있다. 

*   오늘날휴대용 시스템은 이멜일이나 웹브라우징뿐만 아니라 음악 연주, 비디오, 디지털 책 읽기, 사진 활영 및 고품질 비디오의 녹화 등에 사용된다. 따라서 이들 장치에서 수행되는 다양한 범위의 응용에서 엄청난 성장이 계속되고 있다. 많은 개발자들은 이제 전역 위치 시스템 칩, 가속도계와 자이로스코프의 독특한 기능을 활용하는 들을 설계하고 있다. 내장된 GPS  칩은 휴대장치가 위성을 사용하여 위성의 정확한 위치를 알 수 있게 한다. 이 기능은 운항을 제공하는 응용, 예를 들면 어디로 걷거나 운전할 지를 말해주거나 사용자에게 식당과 같은 인접한 서비스로 안내하면 어디로 걷거나 운전할 지를 말해주거나 사용자에게 식당과 같은 인접한 서비스로 안내하는 응용의 설계에 유용하다. 가속도계는 휴대장치가 땅에 대한 자신의 위치를 탐지하고 또는 기울거나 흔드는 등의 다른 힘을 탐지할 수 있게 한다. 가속도계를 이용하는 다수의 컴퓨터 게임은 시스템과 플레이어가 마우스나 키보드가 아니라 휴대장치를 기울이거나 돌리거나 흔드는 것을 통해 인터페이스 한다. 아마도 이러한 기능의 보다 실용적 이용은 증강현실일 것이다. 증강현실에서는 현재 환경의 디스플레이 위에 정보를 겹치게 한다. 전통적 랩톱이나 데스크톱에서 이러한 응용을 개발하기는 상상하기 어려울 것이다. 

*   온라인 서비스에 접근을 허용하기 위해 휴대장치는 전형적으로 IEEE 표준 802.11 무선 또는 휴대 전화 데이터망을 사용한다. 그렇지만 휴대장치의 메모리 용량과 처리속도는 PC보다는 제한적이다. 스마트폰이나 태블릿은 64GB의 저장장치를 가지는 반면, 데스크톱은 1TB의 저장장치를 가진다. 비슷하게 전력소모가 대단한 관심사이기 때문에 휴대장치는 종종 전통적 데스크톱이나 랩톱 컴퓨터의 처리기보다 작고, 느리며, 보다 적은 수의 처리기 코어를 갖는다. 현재 휴대 컴퓨팅에서 두 개의 지배적인 운영체제는 애플 IOS와 구글의 Android이다.  

### 11.3 분산 시스템 

*    분산 시스템은 물리적으로 떨어져 있는 이기종 컴퓨터들의 집합이다. 분산 시트템의 컴퓨터들은 사용자가 시스템 내의 다양한 지원들을 접근 할 수 있도록 네트워크로 연결되어 있다. 공유 자원에 대한 접근은 계산 속도와 기능, 데이터 가용성 및 신뢰성을 향상시킨다. 몇몇 공유 자원에 대한 접근은 계산 속도와 기능, 데이터 가용성 및 신뢰성을 향상시킨다. 몇몇 운영체제는 네트워킹의 자세한 사항을 네트워크 인터페이스의 디바이스 드라이버에 포함시킴으로써 네트워크에 대한 접근을 파일 접근 형태로 일반화 시킨다. 다른 운영체제들은 사용자가 특정 네트워크 기능을 명시적으로 호출하게 한다. 일반적으로 시스템 상에는 두 모드가 혼재되어 있으며 그 예로 FTP와 NFS를 들 수 있다. 분산 시스템을 만드는 프로토콜은 시스템의 유용성과 대중성에 큰 영향을 줄 수 있다. 

*   네트워크는 가장 단순하게 보면 두 개 이상 시스템 간의 통신 경로이다. 분산 시스템의 많은 기능들은 네트워킹에 의존하고 있다. 네트워크는 사용되는 프로토콜, 노드간의 거리, 그리고 전송 매체에 따라 다른다. 비록 ATM과 여타 프로토콜들이 널리 사용되고 있지만 TCP/IP가 가장 일반적인 네트쿼크 프로토콜로 인터넷의 기본 구조를 제공한다. 모든 범용 운영체제를 포함하여 대부분의 운영체제는 TCP/IP를 지원한다. 일부 시스템은 자신들의 필요를 위해 사유의 프로토콜을 지원한다. 운영체제에게 네트워크 프로토콜은 단순히 예를 들면 네트워크 어댑터와 같은 인터페이스 장치와 그것을 관리하기 위한 장치 드라이버와 통신 프로토콜이 데이터를 처리하기 위한 소프트웨어가 필요하다.

*   네트워크는 노드 간의 거리에 의해 타입이 결정된다. LAN은 한 방, 한 층, 또는 한 건물에 존재한다. WAN은 통상 건물, 도시 또는 국가 사이를 연결한다. 다국적 기업은 전 세계에 퍼져 있는 사무실을 연결하기 위하여 WAN을 사용할 수 있다. 이들 네트워크는 하나 또는 다수의 프로토콜을 사용할 수 있다. 새로운 기술의 개발에 따라 새로운 형태의 네트워크가 생겨나고 있다. 예를 들면 메트로폴리턴 에리어 네트워크(MAN)는 한 도시 내의 건물들을 연결할 수 있다. 블루투스와 802.11 장치는 무선 통신 기술을 사용하여 수미터 짧은 거리에서 통신하며 실질적으로 전화기와 헤드셋 사이 또는 스마트폰과 데스크톱 컴퓨터 사이에 개인 에리어 네트워크(personal-area network, PAN)을 만든다. 

*   네트워크에 사용되는 매체도 또한 다양하다. 이들은 구리 전선, 섬유 가닥, 또는 위성, 마이크로웨이브 접시, 및 라디오 사이의 무선 전송 등을 포함한다. 계산 장치가 휴대폰에 연결되면 네트워크를 형성한다. 아주 짧은 적외선 통신도 네트워크를 위해 사용될 수 있다. 아주 초보적인 수준에서 컴퓨터는 통신할 때마다 네트워크를 사용하거나 생성한다. 이들 네트워크는 성능과 신뢰도에 차이가 있다. 

*   어떤 운영체제든 네트워크 연결을 제공하는 차원을 넘어 네트워크와 분산 시스템의 개념을 더욱 더 확장시킨다. 네트워크 운영체제는 네트워크를 통한 파일의 공유, 다른 컴퓨터상에 존재하는 다른 프로세스들끼리의 메시지 교환을 제공하는 운영체제이다. 네트워크 운영체제를 수행하는 컴퓨터는 네트워크상의 다른 컴퓨터들과 연결되어 있고 통신이 가능하더라도 독자적으로 행동한다. 분산 운영체제는 그에 비해 덜 독자적인 환경을 제공한다. 다른 운영체제들끼리 하나의 운영체제가 네트워크를 제어하는 것처럼 보이기 위하여 서로 밀접하게 통신한다. 

### 11.4 클라이언트 서버 계산

*   PC가 빨라지고, 보다 강력해지고 또한 저렴해짐에 따라 설계자들은 중앙식 시스템으로부터 이탈하기 시작했다. 중앙식 시스템에 연결된 터미널은 PC와 휴대용 장치에 의해 대체되고 있다. 따라서 과거에는 중앙 시스템에 직접 취금되던 사용자 인터페이스 기능들도 PC에 의해 종종 웹 인터페이스를 통해 처리되고 있다. 그 결과 오늘날의 시스템은 클라이언트 시스템에 의해 생성되는 요구를 만족시키기 위한 서버 시스템으로 동작한다. 이런 특별한 분산 시스템을 클라이언트-서버 시스템이라고 부르며, 그 일반적 구조가 아래 그림에 나와 있다. 

* 서버 시스템은 넓게는 계산 서버와 파일 서버로 분류 될 수 있다.                                  >   1. 계산 서버 시스템은 클라이언트가 어떤 작업을 요청할 수 있는 인터페이스를 제공한다. 그 결과로 서버는 그 작업을 수행하고 결과를 클라이언트에게 돌려보낸다. 클라이언트의 데이터 요청에 응답하는 데이터베이스를 실행하고 있는 서버가 이러한 시스템의 한 예이다. 
          `
>   2. 파일 서버 시스템은 클라이언트가 파일을 생성, 갱신, 읽기 및 제거할 수 있는 파일 시스템 인터페이스를 제공한다. 이러한 시스템의 예로서 웹 브라우저 클라이언트에게 파일을 전달하는 웹 서버를 들 수 있다. 

### 11.5 피어 간 계산 

*   분산 시스템의 다른 구조는 피어 간 시스템(P2P)이다. 이 모델에서는 클라이언트와 서버가 서로 구별되지 않는다. 대신 시스템 상의 모든 노드가 피어로 간주되고 각 피어는 서비스를 요청하느냐 제공하느냐에 따라 클라이언트 및 서버로 동작한다. 피어 간 시스템은 전통적인 클라이언트 서버에 비해 장점을 제공한다. 클라이언트 서버 시스템에서는 서버가 병목으로 작용한다. 그러나 피어 간 시스템에서는 서비스가 네트워크에 분산된 여러 노드에 의해 제공될 수 있다. 

*   피어 간 시스템에 참여하기 위해서는 노드는 먼저 피어간 네트워크에 참가해야 한다. 네트워크에 참가하게 되면 네트워크의 다른 노드에게 서비스를 제공하거나 서비스를 요청할 수 있다. 어떤 서비스가 가능한 지를 결정하는 방법에는 다음의 두 일반적인 방법이 있다. 

>   1. 노드가 네트워크에 참가할 때 네트워크의 중앙 검색 서비스에 자신이 제공하는 서비스를 등록한다. 특정 서비스를 원하는 노드는 먼저 이 중앙 검색 서비스를 통하여 어떤 노드가 서비스를 제공하는지 확인하여야 한다. 나머지 통신은 클라이언트와 서비스 제공자 사이에서만 발생하게 된다. 

>   2. 위의 대안 기법은 중앙 검색 서비스를 사용하지 않는다. 클라이언트로 동작하는 피어는 원하는 서비스를 제공하는 노드를 찾아내기 위하여 네트워크상의 모든 노드에게 서비스 요청 메시지를 방송한다. 그 서비스를 제공하는 노드 또는 노드들은 피어에게 응답메시지를 보낸다. 이 방법을 지원하기 위해서는 피어들이 다른 피어들이 제공하는 서비스를 발견하기 위한 발견 프로토콜이 제공되어야 한다. 

*   피어 간 네트워킹은 개인 간의 파일 교환을 가능하게 해주는 Napster, Gnutella와 같은 파일 공유 서비스 때문에 1990년 후반에 많은 인기를 얻었다. Napster 시스템은 앞서 설명한 첫번째 방식과 유사한 방법을 사용하였다. 중앙 서버가 Napster 네트워크상에 존재하는 모든 노드들이 가지고 있는 파일의 인덱스를 유지하고 실제 파일의 전송은 피어 노드 사이에서 일어난다. Gnutella 시스템은 두 번째 방법과 유사한 방식을 사용하였다. 클라이언트는 파일 전송 요청을 방송하고 요청을 수행할 수 있는 서버는 그 클라이언트에게 직접 응답한다. 파일 교환의 미래는 파일들이 저작권으로 보호되고, 이 파일들의 배포를 금지하는 법이 존재하기 때문에 불투명하다. 주목할 사례로 Napster가 저작권 침해로 법적 분쟁을 겪었으며, 2001년 그 서비스가 중단되었다. 

*   Skype가 피어간 계산의 또 다른 예이다. SKype는 클라이언트가 인터넷을 통해 IP음성이라 알려진 기술로 음성 통화나 비디오 통화를 할 수 있게 된다. 스카이프는 절충형 피어간 접근을 사용한다. 중앙형 로그인 서버를 가지며 분산형 피어를 사용하여 두 피어가 서로 통신할 수 있게 된다. 

### 11.6 가상화
*   
### 11.7 클라우드 컴퓨팅

*   클라우드 컴퓨팅은 계산, 저장장치는 물론 응용조차도 네트워크를 통한 서비스로 제공하는 계산 유형이다. 어떤 면에서 클라우드 컴퓨팅은 가상화를 그 기능의 기반으로 사용하기 때문에 가상화의 논리적 확장이다. 예를 들면 아마존 Elastic Compute Cloud(EC2) 설비는 수천의 서버, 수백만의 가상 기계 및 페타 바이트의 저장장치를 인터넷 상의 누구든지 사용할 수 있게 한다. 사용자는 자신이 사용하는 자원량에 따라 매달 사용량을 지불한다. 

*   아래를 포함하여 여러 유형의 클라우드 컴퓨팅이 존재한다. 
![ 클라우드 컴퓨팅 ](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter1/1_21_CloudComputing.jpg)


*   클라우드 컴퓨팅 환경은 다수 유형의 조합을 제공하기 때문에 이들 클라우드 컴퓨팅의 유형들은 서로 독립적이지 않다. 예를 들면 한 조직이 공중 서비스로 SaaS와 laaS를 모두 제공할 수 있다. 

*   물론 많은 유형의 클라우드 하부구조 내에 전통적인 운영체제가 존재한다. 그 위에는 사용자 프로세스가 수행되는 가상기계를 관리하는 VMM이 있다. 더 위로는 Vware vCloud Director나 오픈 소스인 Euclayptus 툴 셋트와 같은 클라우드 관리 도구가 있어야 VMM을 관리한다. 이들 도구들은 주어진 클라우드의 자원을 관리하며, 클라우드 구성요소들에 대한 인터페이스를 제공하므로 이들을 새로운 유형의  운영체제로 볼 수 있는 근거를 제공한다. 

*   상기 그림은 Iaas를 제공하는 공중 클라우드를 보인다. 클라우드 서비스와 클라우드 사용자 인터페이스가 모두 방화벽에 의해 보호되는 것에 익숙하다.
### 11.8 실시간 내장형 시스템 


## 12. 오픈소스 운영체제 





























