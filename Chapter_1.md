## 0. 서론 
운영체제란 컴퓨터 하드웨어를 관리하는 프로그램이다. 운영체제는 또한 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. 이러한 일들을 수행하기 위한 다양한 방법이 존재하며, 크게 편리성과 효율성의 조합으로 설계 되었다. 이 장에서는 현대 컴퓨터 시스템의 주요 구성요소와 운영체제가 제공하는 기능에 대한 일반적인 개관을 제공한다. 



## 1. 운영체제가 할 일
*   전체 컴퓨터 시스템에서 운영체제가 수행하는 역할에 대해 살펴보자. 컴퓨터 시스템은 크게 4가지 구성 요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다. 운영체제는 정부와 유사하여, 그 자체로는 유용한 기능을 수행하지 못한다. 그러나 컴퓨터 시스템이 동작할 때 이들 자원을 적절하게 분배하고 다양한 응용 프로그램간의 하드뒈어 사용을 제어 및 조절한다. 


## 1.1 사용자 관점
*   컴퓨터에 대한 사용자의 관점은 인터페이스에 따라 달라진다. 

### 1.1.1 개인 PC
*   모니터, 키보드, 마우스로 구성된 PC에서 작업을 수행한다. 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었다. 따라서 사용의 용이성에 중점을 두고 설계되고 성능에는 약간의 신경을 쓰고 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되는지에는 거의 신경을 쓰지 않는다. 

### 1.1.2 대형 컴퓨터 혹은 미니 컴퓨터에 연결된 터미널
*   다수의 사용자가 터미널을 통해 동일한 컴퓨터에 접근하고 있다. 이들 사용자들은 자원을 공유하며 정보를 교환할 수 있다. 이 경우 운영체제는 자원 이용을 극대화하도록 설계된다. CPU 시간, 메모리 및 입출력은 효율적으로 사용되며 각 개인 자신의 정당한 몫만 사용할 수 있다. 

### 1.1.3 워크스테이션 혹은 서버
*   사용자는 개인이 마음대로 사용할 수 있는 전용 자원을 갖지만 이들은 또한 네트워크, 서버-파일, 계산 및 프린터 서버를 공유한다. 따라서 운영체제는 개인의 사용 용이성과 자원 이용 간에 적절히 조화를 이루도록 설계되어 있다. 

### 1.1.4 휴대용 컴퓨터 
*   이들은 개인 사용자들을 위한 독립형 장치이며 전화망이나 무선 기술을 통해 네트워크에 연결된다. 휴대용 컴퓨터의 사용자 인터페이스는 터치 스크린을 사용하며, 이를 통해 사용자들은 키보드나 마우스 대신 손가락으로 스크린을 누르거나 밀어 시스템과 상호 작용한다. 

### 1.1.5 기타
*   가전제품 혹은 자동차 내의 내장형 컴퓨터의 경우 사용자 관점이 매우 작은 비중을 차지한다. 이와 같은 컴퓨터나 운영체제는 사용자의 개입없이 작동하도록 설계되어 있다. 


## 1.2 시스템 관점

### 1.2.1 자원 할당자
*   컴퓨터 시스템의 경우 문제를 해결하기 위해 요구되는 여러 가지 자원들 ( CPU시간, 메모리 공간, 파일 저장 공간, 입출력 장치)의 관리자로서 동작하며, 작업을 위해 특정 프로그램과 사용자에게 필요한 자원을 할당한다. 자원에 대한 서로 상충될 수 있는 요청이 있기 때문에, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지를 결정해야한다. 

### 1.2.2 제어 프로그램
*   컴퓨터의 부적절한 사용을 방지하기 위해서 사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊이 관여한다. 


## 1.3 운영체제의 간략한 역사 및 정의

*   운영체제가 존재하게 된 이유는 유용한 컴퓨터 시스템을 만드는 과정에서 발생하는 문제점을 해결하기 위한 적절한 방법이기 때문이다. 컴퓨터 시스템은 사용자의 프로그램을 실행하고, 사용자의 문제를 쉽게 해결해 주기위해 존재한다. 이러한 과정에서 컴퓨터 하드웨어가 제작되고, 순수 하드웨어 만으로는 사용하기 쉽지 않으므로 응용프로그램이 개발되었다. 이후 다양한 응용 프로그램들은 입출력 장치의 통제와 같은 공통적인 연산을 필요로 하게 된다. 여기에 자원을 제어하고 할당하는 공통 기능을 하나의 소프트웨어로 통합한 것이 오늘날의 운영체제이다.

*   초장기 컴퓨터는 암호 깨기와 탄도 계산과 같은 특수 목적 시스템으로 사용되었다. 그러나 이후 컴퓨터는 범용의 다기능 대형컴퓨터로 발전하였고 그즈음 운영체제가 탄생하게 되었다. 컴퓨터의 기능이 확대되고 크기는 작아졌으며, 용도가 다양해 졌고, 그에 맞춰 다양한 운영체제가 생겨났다. 이러한 다양한 운영체제에 대한 완벽한 정의는 존재하지 않는다. 다만 일반적인 정의로 운영체제는 컴퓨터에서 항상 수행되는 프로그램으로 일반적으로 커널이라 불린다. 그러나 오늘날 휴대용 장치의 운영체제를 보면 운영체제를 구성하는 기능의 수가 증가함을 볼 수 있다. 휴대용 운영체제는 종종 핵심 커널외에 미들웨어 ( 응용 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크 집합)을 포함한다. 예를 들어 IOS, 안드로이드는 핵심 커널과 더불어 데이터베이스, 멀티미디어 및 그래픽스를 제공한다.  



## 2. 컴퓨터 시스템의 구성 


## 2.1 컴퓨터 시스템 연산

### 2.1.1 컴퓨터 시스템 구조

*   컴퓨터 시스템은 CPU, 공유 메모리, 장치 제어기, 공통 버스로 구성되어 있다. CPU, 장치 제어기는 공유 메모리에 대한 접근을 제공하는 공통 버스에 의해 연결되어 있다 (하기 그림 참조).

> I/O Interface란 무엇인가?

> 입출력 인터페이스, 입출력 채널, 입출력 프로세서, 입출력 제어기, 장치 제어기등 다양한 이름으로 불린다. 
이러한 인터페이스가 필요한 이유는 주변 장치의 경우 데이터의 형식 및 전송 속도의 차이로 
중앙 처리 장치와 주기억장치와의 직접적인 통신이 불가능하기 때문이다.  

*   각 장치제어기는 특정 장치( 디스크 드라이브, 오디오 장치 등 )을 관리하고 있으며 메모리 사이클을 얻기 위해 CPU와 경쟁하며 병렬 수행된다. 메모리 제어기는 메모리에 대한 접근을 동기화 함으로써 공유 메모리에 대한 질서 있는 접근을 유지한다. 

*   ![현대의 컴퓨터 시스템](https://t1.daumcdn.net/cfile/tistory/2772A041535305A41B)

### 2.1.2 컴퓨터 시스템 구동 과정

*   컴퓨터가 구동을 시작하기 위해서는 수행할 초기 프로그램이 필요하며 이를 부트스트랩 프로그램이라 지칭한다. 부트스트랩 프로그램은 보통 펌웨어라고 알려져 있는 컴퓨터 내의 읽기 전용 메모리나 EEPROM에 저장된다. 이것은 CPU 레지스터로부터, 장치 제어기, 메모리 내용등을 포함한 시스템의 모든 면을 초기화한다. 또한 부트스트랩 프로그램에는 운영체제를 적재하는 방법 및 수행을 시작하는 방법이 포함되어 있다. 따라서 부트스트랩 프로그램은 최종적으로 운영체제의 커널을 찾아 메모리에 적재하게 된다. 

> EEPROM이란?

> EEPROM을 설명하기에 앞서 우선 ROM의 변천 과정에 대해서 알아보겠다. ROM은 Read-only memory의 줄임말로, 말 그대로 읽기만 가능한 메모리라는 뜻이다. 하지만 이건 아주 옛날 이야기고, 최근 생산되는 대부분의 ROM은 적어도 한번 이상은 정보를 수정 가능하게끔 되어있다.

> ROM이 처음 세상에 등장했을 때는 공장에서 제조될때 바로 데이터가 저장되어 고정된 채 생산되었다. 그랬기 때문에 후에 데이터를 변경하는 것이 불가능 했다. 여기서 한발자국 더 나아간 것이 PROM이다. PROM(Programmable ROM)은 이름에서 보다시피 '프로그래밍 가능한' 롬이다. 프로그래밍 가능하다는 것은 내부의 회로를 변경해서 데이터를 수정할 수 있다는 말이다. 그러나 내부의 퓨즈를 끊어서 정보를 저장하는 방식이기 때문에 한번 데이터를 설정하면 그 이후에는 변경하지 못한다. 

>이것을 보완해서 나온 것이 EPROM(Erasable PROM)이다. EPROM은 자외선을 이용해서 정보를 지우며, 여러번 썼다 지웠다 할 수 있다. EPROM을 다시 보완해서 나온 것이 오늘 살펴볼 EEPROM이다. 자외선을 이용해서 정보를 지워야 하는 EPROM과는 다르게 전기적으로 지웠다 썼다 할 수 있기 때문에 쓰는 속도가 매우 빠르고, 전용 롬라이터(롬을 기록할 수 있도록 해주는 장비)가 없어도 손쉽게 다룰 수 있다. 심지어 EEPROM을 RAM의 대용으로 사용하는 경우도 있다. 예를 들어 Atmega328같은 마이컴에는 내부에 약 1kb정도의 EEPROM이 있는데, RAM용량이 부족한 경우 RAM대용으로 상수나 자주 사용하지 않는 변수 등을 여기에 담아서 활용하기도 한다. 물론 RAM보다는 훨씬 느리므로 사용하는데 한계는 있다.

> 출처 : https://kcal2845.tistory.com/37

*   커널이 적재되고 수행이 시작되면 시스템과 사용자에게 서비스를 제공할 수 잇다. 일부 서비스는 커널이 아닌 시스템 프로그램에 의해 제공되며 이들은 부트 시에 메모리에 적재되어 커널이 수행되는 동안 계속 수행되는 시스템 프로세스나 시스템 디먼이 된다. 유닉스에서는 첫 시스템 프로세스가 "init"이며, INIT에 의해 다른 많은 디먼이 시작된다. 이 단계가 끝나면 시스템이 완전히 부트된 상태이며 시스템은 이벤트 발생을 대기하게 된다. 

### 2.1.3 인터럽트(Interrupt)와 시스템 호출(System Call)

*   이벤트가 발생하면 하드웨어나 소프트웨어로부터 발생한 인터럽트에 의해 신호가 보내진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. 소프트웨어는 시스템 콜을 통해 인터럽트를 발생시킬 수 있다. 
*   CPU에 인터럽트가 도착하면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이 실행된다. 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 중단 되었던 연산을 재개한다. 
*   위와 같은 전달을 처리하는 직선적인 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러를 호출한다. 그러나 인터럽트는 매우 빠르게 처리되어야 하고, 사용 가능한 인터럽트의 수가 미리 정의되어 있으므로, 일반적인 루틴 호출 대신 테이블을 통하여 간접적으로 인터럽트 루틴이 호출 될 수 있다. 이러한 테이블에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있으며, 하위 메모리에 저장된다. 이 경우 인터럽트가 요청되면, 인터럽트를 유발한 장치를 우한 인터럽트 서비스 루틴의 주소를 제공하기 위해, 이 주소의 배열 즉, 인터럽트 벡터가 인터럽트 요청과 함께 주어진 고유의 유일한 장치번호로 색인된다. 
*   인터럽트 구조는 중단된 명령의 주소를 반드시 저장해야 된다. 최근 운영체제는 시스템 스택에 복귀 주소를 저장하며, 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요가 있다면, 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다. 인터럽트를 수행하고, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작된다. 

> [Interrupt 참고자료](https://slidesplayer.org/slide/14981607/)

## 2.2 저장 장치 구조 
### 2.2.1 저장 장치의 동작 과정 
*   CPU는 명령어를 단지 메모리로부터 가져올 수 있으므로 프로그램을 수행하기 위해서는 반드시 프로그램이 메모리에 적재되어 있어야한다. 범용 컴퓨터는 대부분의 프로그램을 주 메모리라 불리는 재기록 가능한 메모리에서 가져 오며, 이는 DRAM이라 불리는 반도체 기술로 구현된다. 앞서 살펴 보았듯이 EPPROM의 경우 펌웨어를 저장하기 위한 용도로 주로 사용되며, 예들 들어 스마트폰은 공장에서 설치한 프로그램을 저장하기 위해 EPPROM을 사용한다.   
*   모든 형태의 메모리는 바이트의 배열을 제공한다. 그리고 각 바이트는 자신의 주소를 가지고 있으며 크게 적재와 저장이 가능하다. 적재 명령은 주 메모리로부터 CPU 내부의 레지스터로 한 바이트 혹은 워드를 옮기는 것이다. 반대로 저장명령은 CPU 레지스터의 내용을 주 메모리로 옮긴다. 
*   폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을 명령 레지스터에 저장한다. 이어서 명령을 해독하고, 이 과정에서 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 이 후 결과가 다시 메모리에 저장될 수 있다. 이상적으로는 프로그램과 데이터가 주 메모리에 영구히 존재하면 좋겠으나 이는 하기 서술할 2가지 이유 때문에 불가하다. 첫 번째로 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다. 두 번째로 주 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 장치이다. 따라서 대부분의 컴퓨터 시스템은 주 메모리의 확장으로 보조 저장 장치를 제공한다. 가장 일반적인 보조 저장 장치로는 프로그램과 데이터를 모두 저장할 수 있는 자기 디스크가 존재한다. 대부분의 프로그램은 메모리에 적재될 때까지 디스크에 저장된다. 

### 2.2.2 저장 장치의 종류 및 특징

*   앞서 기술된 주 메모리 및 자기디스크외에도 다양한 저장장치가 존재하며 이를 하기의 그림처럼 하나의 계층으로서 표시할 수 있다. 

![저장 장치 계층](https://3.bp.blogspot.com/-HJnfPCXn2hs/WLv8yzbggrI/AAAAAAAAAt0/tLiPFBO6cDQhqOa5k_8GaTIIx_iBq3SZACLcB/s1600/010_Memory1.png)

*  상위 계층으로 갈 수록 접근 시간을 단축되나, 가격이 비싸지고 비트 당 비용이 증가한다. 서로 다른 비용과 속도를 갖는 것 외에도 휘발성 혹은 비휘발성의 특징을 가진다. 상기 그림에서 반도체 디스크의 위의 저장 시스템은 휘발성이며, 반면 반도체 디스크 및 그 아래의 장치들은 비휘발성이다. 반도체 디스크의 경우 다수의 종류가 존재하나 일반적으로 자기 디스크보다 빠르며 비휘발성이다. 반도체 디스크의 예시 중 하나는 플래시 메모리이다. 플래시 메모리는 카메라 및 PDA등에 사용되고 있으며 점차 범용 컴퓨터의 저장장치로 영역을 확대하고 있다. 완전한 메모리 시스템의 설계를 위해서는 이러한 요인들 간의 균형을 맞추어야 한다. 즉, 필요한 만큼의 상위 계층의 저장장치를 사용하며, 가능한 많은 비휘발성 메모리를 제공해야한다. 두 구성요소간의 전송률 혹은 시간에 차이가 날 경우 캐시의 도입또한 고려되어야한다. 


## 2.3 입출력 구조 
*   #1에서 잠시 언급하였듯이, 현대의 컴퓨터 시스템은 공통 버스에 의해 연결된 여러 개의 장치 제어기와 CPU로 구성되어 있다. 각 장치 제어기가 특정 타입의 장치를 담당한다. 개별 장치제어기는 약간의 로컬 버퍼 저장 장치와 특수 목적용 레지스터 집합을 유지한다. 장치 제어기는 자신이 제어하는 주변 장치와 자신의 로컬 버퍼 저장 장치 사이의 데이터 전송을 담당한다. 이 때 장치 제어기에 따라 하나 이상의 장치가 부착 될 수 있다. 예를 들어 SCSI 제어기에는 7개 이상의 장치가 부착 될 수 있다. 통상적으로 운영체제는 각 장치 제어기 마다 디바이스 드라이버를 가지고 있으며, 디바이스 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분에게 일관된 인터페이스를 제공한다. 

### 2.3.1 입출력 장치의 동작 
*   입출력 연산을 시작하기 위해, 디바이스 드라이버는 장치 제어기의 적절한 리지스터에 필요한 값을 적재한다. 장치 제어기는 동작을 결정하기 위해 레지스터의 내용을 조사한다. 이후 제어기는 장치로 부터 자신의 로컬 버퍼로 데이터 전송을 시작한다. 일단 데이터의 전송이 완료되면, 장치 제어기는 자신이 연산을 완료했음을 인터럽트를 통해 디바이스 드라이버에게 알린다. 그러면 디바이스 드라이버는 제어를 운영체제에게 반환하고 상태에 따라 데이터 혹은 데이터에 대한 포인터를 같이 반환할 수 있다.
*   위와 같은 방식은 많은 양의 데이터를 전송하는 데에는 높은 오버헤드를 초래한다. 이 문제를 해결하기 위해 도입된 기법이 DMA(Direct Memory Access)장치가 사용된다. 장치에 대한 버퍼, 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입없이 메모리로부터 혹은 메모리로 데이터 블록을 전송한다. 한 바이트마다 인터럽트가 발생하는 것이 아닌 블록 전송이 완료될 때 인터럽트가 발생하게 된다. 따라서 CPU는 장치 제어기가 데이터를 전송하는 동안 다른 작업을 수행할 수 있다. 일부 시스템의 경우 버스 대신에 스위치 구조를 사용한다. 이 경우에는 공유 버스를 사용하기 위한 경쟁이 존재하지 않고, 다수의 구성요소가 서로 동시에 통신하는 것이 가능하다. 이 때 DMA의 사용은 더욱 효과적이다. 

![DMA](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F993AB04A5C8391F5237D04)

## 3. 컴퓨터 시스템 구조 
### 3.1 단일 처리기 시스템
단일 처리기 시스템은 사용자 프로세스의 명령어를 포함하여 범용 명령어 집합을 수행할 수 있는 하나의 주 CPU를 가진다. 또한 대부분의 시스템들은 특수 목적의 전용 처리기를 가지고 있다.이 전용 처리기는 디스크나 키보드 또는 그래픽 제어기와 같은 특정 장치 처리기의 형태이거나 메인프레임에서와 같이 시스템이 구성요소들 간의 데이터를 빠르게 전송할 수 있는 입출력 처리기와 같은 범용 처리기에 가까운 형태로 제공 될 수도 있다. 이러한 전용 처리기들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지 않는다. 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는 이 처리기들이 수행할 다음 태스크에 대한 정보를 보내고 처리기들의 상태를 감시한다. 예를 들어 디스크 제어기 마이크로프로세서는 주 CPU로 부터 연속된 요청을 받아들여 자기 고유의 디스크 큐와 스케쥴링 알고리즘을 구현한다. 이 배합은 CPU가 직접 디스크 스케쥴링을 진행해야 하는 오버헤드를 감소시킨다.상기에 기술한 전용 마이크로프로세서의 사용 여부에 관계 없이 범용 CPU의 개수에 의하여 단일 처리기 시스템 혹은 다중 처리기 시스템이 분류된다. 

### 3.2 다중 처리기 시스템
*   다중 처리기 시스템이란 매우 밀접한 통신을 하는 하나 이상의 처리기들을 가지며, 컴퓨터 버스, 클락 메모리와 주변 장치를 공유하는 시스템을 지칭한다. 다중 처리기 시스템은 크게 두 가지 형태를 가진다. 첫 번째는 비대칭적 다중 처리라 지칭되며, 주 처리기와 부 처리기가 존재한다. 주 처리기는 작업을 스케줄하고 종속 처리기에 작업을 할당한다. 부 처리기는 명령을 처리하거나 미리 정의된 태스크를 수행한다. 두 번째는 대칭적 다중 처리라 지칭되며, 가장 일반적인 다중 처리기 시스템이다. 대칭적 다중 처리 시스템에서는 각 처리기가 운영체제 내의 모든 작업을 동등하게 수행하게 된다. 하기 그림은 전형적인 대칭적 다중 처리( Symmertic multiprocessing )의 형태를 나타낸다. 그림에서 확인할 수 있듯이 각 처리기는 자신의 레지스터와 캐시를 가지만 메모리를 공유하는 형태를 가진다. 

![대칭적 다중 처리 구조](https://t1.daumcdn.net/cfile/tistory/2627103E5353067F2B)

*   대칭적 다중처리와 비대칭적 다중 처리의 차이점은 하드웨어나 소프트웨어의 결과 일 수 있다. 특수한 하드웨어가 다중처리기들을 차별화 할 수 있으며, 또는 한 개의 주 처리기와 다수의 종 처리기를 허용하도록 소프트웨어를 설계할 수 있다. 그에 대한 예로 Sun의 운영체제인 SunOS는 버전에 따라 대칭적 다중 처리와 비대칭적 다중 처리를 제공한다. 

*   다중 처리에서는 계산 능력을 높이기 위해 CPU를 추가할 수 있다. 만일 CPU가 통합된 메모리 제어기를 가졌다면, CPU를 추가하여 시스템에서 주소 지정 가능한 메모리의 양을 늘릴 수 있다. 어떻든 다중처리는 메모리 접근 모델을 균등 메모리 접근에서 비균등 메모리 접근으로 변경하게 만들 수 있다. NUMA의 경우 UMA와는 다르게 메모리에 접근하는 시간이 프로세서와 메모리의 상대적인 위치에 따라서 달라진다. 아래의 그림으로 설명을 추가하면 시스템에 CPU 소켓이 네 개 있고, 512GB의 메모리가 설치되어 잇다면 물리 주소 0 ~ 128GB까지의 메모리는 0번 소켓에, 128 ~ 256GB까지의 메모리는 1번 소켓의 지역메모리가 되는 방식이다. 각 소켓에서 지역 메모리에 접근할 때는 원격 메모리에 접근할 때보다 훨씬 빠르게 데이터를 읽고 쓸 수 있다. 하나의 CPU코어에 여러 개가 들어가 있는 경우에는 같은 지역 메모리를 사용하는 CPU 코어들을 묶어서 하나의 NUMA 노드로 관리한다. 8코어 4소켓의 경우에는 0 ~ 7번 코어에는 NUMA 노드 0번, 8 ~ 15번 코어는 NUMA 노드 1번과 같이 할당되게 된다. 

![Intel 네할렘 NUMA 구조](https://www.researchgate.net/profile/Raul_De_la_Cruz/publication/285393464/figure/fig3/AS:670015036612628@1536755441422/Diagram-of-a-dual-socket-configuration-with-Intel-Nehalem-EP.png)

*   최근의 CPU는 하나의 칩에 여러 개의 코어를 포함시키는 것이 일반적이다. 이러한 다중 처리기 시스템을 멀티코어라고 지칭한다. 이들은 단일 코어를 가진 여러 개의 칩보다 효율적이며, 이는 칩 내의 통신이 칩 사이의 통신보다 빠르기 때문이다. 또한 여러 개의 단일 칩에 비하여 전력을 훨씬 덜 소모한다. 3.3절에서 후술하겠지만, 멀티코어 시스템은 다중 처리기 시스템인 반면에 모든 다중 처리기 시스템이 멀티코어인것은 아니다. 하기 그림에서는 한 칩에 두 개의 코어를 가지는 멀티코어를 보인다. 이 설계에서는 각 코어 별로 레지스터와 캐시를 가지나, 다른 설계에서는 공유 캐시를 가지도록 설계 할 수 있다. 이러한 멀티코어는 캐시, 메모리 및 버스 경쟁과 같은 요소를 제외하면, 운영체제의 입장에서는 N개의 표준 처리기처럼 인식된다. 

![멀티코어 설계 예시](https://www.elektronik-kompendium.de/sites/com/bilder/12031711.gif)

*    이 외에 블레이드 서버가 존재한다. 이 블레이드 서버의 경우에는 다수의 처리기 보드 및 입출력 보드, 네트워킹 보드들이 하나의 새시안에 장착되는 형태를 가진다. 일반적인 다중처리기 시스템과의 차이는 각각의 보드가 독립적으로 부팅 될 수 있다는 점이다. 

*   멀티코어 시스템의 경우 크게 3가지 장점을 가진다. 첫 번째는 처리기의 수를 증가시킴으로써, 단위 시간동안 더 많은 일을 처리하도록 할 수 있다. 그러나 N개의 처리기가 있다고 해서 처리량이 N배가 되는 것은 아니며, 이는 다수의 처리기가 하나의 태스크를 처리하기 위해 협력할 경우 오버헤드가 발생하기 때문이다. 두 번째는 규모의 경제이다. 이는 다중 처리기가 하나의 전원 공급 장치, 저장 장치등을 공유하기 때문이다. 이는 각각의 시스템에 동일한 데이터의 복사본을 유지하게 하는 것보다 일반적으로 비용이 저렴하다. 세 번째는 신뢰성의 증기이다. 여러 처리기가 존재할 경우, 한 처리기가 고장나더라도 여분의 처리기가 계속해서 일을 처리할 수 있으며, 단지 수행속도만이 느려질 뿐이다. 이렇게 살아남은 하드웨어의 수준에 비례해 계속적인 서비스를 제공하는 능력을 우아한 퇴보라고 한다. 일부 시스템은 어느 한 구성요소의 고장에도 불구하고 동작을 계속할 수 있기 때문에 우아한 퇴보를 넘어 결함 허용이라고 불린다. 결함 허용 시스템은 오류를 탐지하고, 진단하고 가능하다면 교정할 수 있게 하는 기법이 필요하다. 
 
### 3.3 클러스터형 시스템
*   클러스터 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다는 점에서 1.3.2절에서 설명한 다중 처리기 시스템과 차이가 난다. 그러한 시스템은 약결합이라고 간주된다. 클러스터형에 대한 일반적인 정의는 존재하지 않는다. 그러나 일반적으로 저장 장치를 공유하고 근거리 통신망이나 InfiniBand와 같은 고속의 상호 연결망으로 연결될 경우 이를 클러스터형 컴퓨터라고 지칭한다. 

*   클러스터링은 통상 높은 가용성을 제공하기 위해 사용된다. 즉, 클러스터 내 하나의 컴퓨터가 고장나도 서비스는 계속 제공된다. 일반적으로 고가용성은 시스템에 중복 기능을 추가함으로써 얻어진다. 클러스터 소프트웨어 중 한 층이 클러스터 노드에서 실행된다. 각 노드는 하나 이상의 다른 노드들을 감시한다. 만약 감시받던 노드가 고장나면 감시하던 노드가 고장 난 노드의 저장 장치에 대한 소유권을 넘겨받고 그 노드에서 실행 중이던 응용 프로그램을 다시 시작한다. 사용자와 응용 프로그램의 클라이언트는 잠시 동안의 서비스 중단만을 경험하게 된다. 

*   클러스터링은 대칭 혹은 비대칭적으로 구성될 수 있다. 비대칭형에서는 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 긴급대기 모드를 유지한다. 이 긴급대기 모드에 있는 PC는 활성 서버들을 감시하는 작업만을 수행한다. 서버가 고장 난다면 긴급 대기 모드의 호스트가 활성 서버가 된다. 대칭형 클러스터링에서는 둘 이상의 호스트들이 응용 프로그램을 실행하고 서를 감시한다. 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 보다 효율적이다. 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행가능해야 한다. 

*   한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 고성능 계산환경을 제공하도록 사용될 수 있다. 이러한 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로 단일 처리기나 SMP 시스템 보다 훨씬 큰 계산 능력을 제공할 수 있다. 그렇지만 응용이 클러스터를 이용할 수 있도록 작성되어야 한다. 이는 병렬화라는 기법으로 프로그램을 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 포함한다. 전형적으로 이들은 각 계산 노드가 문제의 일부를 해결한 후 모든 노드의 결과가 결합되어 최종해답을 얻게된다. 

*   다른 형태의 클러스터로 병렬 클러스터와 WAN을 이용한 클러스터가 존재한다. 병렬 클러스터는 여러 호스트가 공유 저장 장치 상의 동일한 데이터를 접근할 수 있게 한다. 대부분의 운영체제가 여러 호스트에 의한 이러한 동시 접근을 지원하지 않으므로 병렬 클러스터는 특수 소프트웨어 버전과 특별히 발매된 응용에 의해 달성된다. 추가적으로 일부 클러스터의 경우 수 킬로미터 떨어진 클러스터 노드뿐만 아니라 한 클러스터 안에서 수십 개의 노드들을 지원한다. 이러한 개선은 후술할 스토리지 에러어 네트워크(SAN)에 의해 가능해졌다. SAN은 여러 호스트를 여러 스토리지 장치에 부착할 수 있게 한다. 만일 으용과 데이터가 SAN에 저장된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에서 수행되도록 으용을 배정할 수 있다. 

## 4. 운영체제의 구조 
*   대부분의 운영체제가 가지고 있는 공통적인 부분에 대하여 이 절에서 설명하기로 한다. 

*   운영체제의 가장 중요한 면 중의 하나는 다중 프로그램이다. 일반적으로 단일 사용자는 CPU 또는 입출력 장치를 바쁘게 유지할 수 없다. 다중 프로그래밍은 CPU가 수행할 작업을 항상 하나이상 가지도록 작업을 구성함으로써 CPU 이용률을 증가시킨다. 

*   이는 다음과 같이 진행된다. 운영체제는 여러 작업을 메모리에 적재하는데, 이는 디스크의 작업 풀로 부터 오게된다. 왜냐하면 메모리 내에 동시에 저장할 수 잇는 작업의 수는 통상 작업 풀에 둘 수 있는 작업의 수보다 훨씬 적기 때문이다. 작업 풀의 디스크 내의 모든 프로세스로 구성되며 이들은 주 메모리로의 할당을 대기하고 있다. 운영체제는 메모리에 적재된 작업 중 하나를 선택해게 실행한다. 결국 이 작업은 입출력의 종료를 기다리는 등과 같이 어떤 일을 기다려야 한다. 다중 프로그래밍 시스템에서는 운영체제가 단순히 다른 작업으로 전환해 그 작업을 수행한다. 이 나중의 작업이 어떤 일을 기다려야 한다면 다시 전환을 수행한다. 따라서 수행할 작업이 하나 이상 있는 한 CPU는 멈추지 않는다. 

*   다중 프로그래밍은 시스템은 여러 가지 시스템 자원을 효율적으로 이용할 수 있는 방법을 제공하지만 사용자를 위해 컴퓨터 시스템과 상호 작용은 제공하지 않는다. 시분할은 다중 프로그래밍의 논리적 확장이다. 시분할 시스템에서는 CPU가 다수의 작업들을 교대로 수행하지만, 매우 빈번하게 교대가 일어나기 때문에 프로그램이 실행되는 동안 사용자들은 각자 자기의 프로그램과 상호작용 할 수 있다. 

*   시분할 시스템은 사용자와 시스템 간에 직접적인 통신을 제공하는 대화식 컴퓨터 시스템을 필요로 한다. 시분할 운영체제는 동시에 많은 사용자가 컴퓨터를 공유하도록 한다. 시분할 시스템에서 각각의 동작이나 명령은 대체로 짧은 경향이 있기 때문에, 각 사용자는 단지 짧은 시간 동안만 CPU 시간이 필요하다. 시스템이 한 사용자에서 다른 사용자로 매우 빠르게 전환되기 때문에, 각 사용자들은 자신이 전체 컴퓨터를 사용하는 것처럼 체감하게 된다. 

*   시분할 운영체제는 위와 같은 기능을 위해 CPU 스케쥴링과 다중 프로그래밍을 사용한다. 각 사용자는 메모리에 최소한 하나의 독립된 프로그램을 가지고 있다. 메모리에 적재되어 있고, 실행되고 있는 프로그램을 일반적으로 프로세스라고 한다. 프로세스가 수행될 때는, 전형적으로 자신이 종료되거나 입출력을 수행할 필요가 있을 때까지 아주 짧은 시간 동안만 실행된다. 입출력은 대화식일 수 있다. 대화식으로 이루어질 경우 예를 들어 입력은 사용자의 타이핑 속도에 영향을 받으며, 사람에게는 빠른 속도 일지라도 컴퓨터의 입장에서는 매우 느린 것이다. 따라서 이러한 대화식 입력이 진행되는 동안 CPU를 쉬게 하지 않고, 운영체제는 CPU를 계속하여 전환시킨다. 

*   시분할과 다중 프로그래밍 운영체제에서는 여러 작업이 메모리에 동시에 유지되어야 한다. 만약 몇몇 작업이 메모리로 옮겨올 준비가 되었고, 그들 전부를 메모리에 보관할만한 공간이 불충분하다면, 시스템은 그들 중 몇 개를 선택해야 한다. 이러한 결정을 하는 것이 작업 스케쥴링이다. 운영체제가 작업 풀에서 하나의 작업을 선택하면, 실행을 위해 그 작업을 메모리에 적재한다. 메모리에 여러 개의 프로그램이 동시에 있을 때 어떠한 형태로는 메모리 관리가 필요하며, 이는 8,9장에서 추가적으로 다룬다. 또 여러 개의 작업이 동시에 실행 준비가 되어 이으면, 시스템은 그들 중 하나를 선택해야 한다. 이러한 결정을 내리는 것을 CPU 스케줄링 이라고 한다. 마지막으로, 병행적으로 수행되는 다수의 작업은 프로세스 스케줄링, 디스크 저장 장치, 그리고 메모리 관리를 포함하여, 운영체제 모든 단계에서 상호간에 영향을 미치는 능력이 제한 될 필요가 있다. 

*   시분할 시스템에서 운영체제는 적절한 응답시간을 보장해야한다. 이는 종종 스와핑에 의해 달성되는데, 스와핑은 프로세스를 주 메모리에서 디스크로 적절하게 스왑인 또는 스왑아웃 한다. 합리적인 응답시간을 보장하는 더 일반적인 방법은 가상메모리 인데, 이것은 일부만 메모리에 있는 작업의 수행을 허용하는 기법이다. 이 기법의 장점은 프로그램이 물리 메모리의 크기보다 커도 된다는 것이다. 더욱이 가상 메모리는 주 메모리를 크고 균등한 저장 장치의 배열로 추상화하여, 사용자에게 보이는 논리 메모리를 물리 메모리로 부터 분리 시킨다. 

*   시분할 시스템은 반드시 파일 시스템도 제공해야 한다. 파일 시스템은 다수의 디스크 상에 존재하므로, 디스크 관리 기법이 반드시 제공되어야 한다. 또한 시분할 시스템은 부적당한 사용으로 부터 자원을 보호하기 위한 기법을 제공해야 한다. 작업이 질서 정연하게 실행되도록 하기 위해, 시스템은 반드시 작업 동기화와 통신 기법을 제공해야 하며, 작업이 서로를 영원히 기다리는 교착 상태에 빠지지 않도록 히야한다. 
   	
## 5. 운영체제 연산
## 6. 프로세스 관리
## 7. 메모리 관리
## 8. 저장장치 관리
## 9. 보호와 보안
## 10. 커널 자료구조 
## 11. 계산환경
## 12. 오픈소스 운영체제 
