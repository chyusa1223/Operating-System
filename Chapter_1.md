## 0. 서론 
운영체제란 컴퓨터 하드웨어를 관리하는 프로그램이다. 운영체제는 또한 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. 이러한 일들을 수행하기 위한 다양한 방법이 존재하며, 크게 편리성과 효율성의 조합으로 설계 되었다. 이 장에서는 현대 컴퓨터 시스템의 주요 구성요소와 운영체제가 제공하는 기능에 대한 일반적인 개관을 제공한다. 



## 1. 운영체제가 할 일
*   전체 컴퓨터 시스템에서 운영체제가 수행하는 역할에 대해 살펴보자. 컴퓨터 시스템은 크게 4가지 구성 요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다. 운영체제는 정부와 유사하여, 그 자체로는 유용한 기능을 수행하지 못한다. 그러나 컴퓨터 시스템이 동작할 때 이들 자원을 적절하게 분배하고 다양한 응용 프로그램간의 하드뒈어 사용을 제어 및 조절한다. 


## 1.1 사용자 관점
*   컴퓨터에 대한 사용자의 관점은 인터페이스에 따라 달라진다. 

### 1.1.1 개인 PC
*   모니터, 키보드, 마우스로 구성된 PC에서 작업을 수행한다. 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었다. 따라서 사용의 용이성에 중점을 두고 설계되고 성능에는 약간의 신경을 쓰고 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되는지에는 거의 신경을 쓰지 않는다. 

### 1.1.2 대형 컴퓨터 혹은 미니 컴퓨터에 연결된 터미널
*   다수의 사용자가 터미널을 통해 동일한 컴퓨터에 접근하고 있다. 이들 사용자들은 자원을 공유하며 정보를 교환할 수 있다. 이 경우 운영체제는 자원 이용을 극대화하도록 설계된다. CPU 시간, 메모리 및 입출력은 효율적으로 사용되며 각 개인 자신의 정당한 몫만 사용할 수 있다. 

### 1.1.3 워크스테이션 혹은 서버
*   사용자는 개인이 마음대로 사용할 수 있는 전용 자원을 갖지만 이들은 또한 네트워크, 서버-파일, 계산 및 프린터 서버를 공유한다. 따라서 운영체제는 개인의 사용 용이성과 자원 이용 간에 적절히 조화를 이루도록 설계되어 있다. 

### 1.1.4 휴대용 컴퓨터 
*   이들은 개인 사용자들을 위한 독립형 장치이며 전화망이나 무선 기술을 통해 네트워크에 연결된다. 휴대용 컴퓨터의 사용자 인터페이스는 터치 스크린을 사용하며, 이를 통해 사용자들은 키보드나 마우스 대신 손가락으로 스크린을 누르거나 밀어 시스템과 상호 작용한다. 

### 1.1.5 기타
*   가전제품 혹은 자동차 내의 내장형 컴퓨터의 경우 사용자 관점이 매우 작은 비중을 차지한다. 이와 같은 컴퓨터나 운영체제는 사용자의 개입없이 작동하도록 설계되어 있다. 


## 1.2 시스템 관점

### 1.2.1 자원 할당자
*   컴퓨터 시스템의 경우 문제를 해결하기 위해 요구되는 여러 가지 자원들 ( CPU시간, 메모리 공간, 파일 저장 공간, 입출력 장치)의 관리자로서 동작하며, 작업을 위해 특정 프로그램과 사용자에게 필요한 자원을 할당한다. 자원에 대한 서로 상충될 수 있는 요청이 있기 때문에, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에 자원을 할당할지를 결정해야한다. 

### 1.2.2 제어 프로그램
*   컴퓨터의 부적절한 사용을 방지하기 위해서 사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊이 관여한다. 


## 1.3 운영체제의 간략한 역사 및 정의

*   운영체가 존재하게 된 이유는 유영한 컴퓨터 시스템을 만드는 과정에서 발생하는 문제점을 해결하기 위한 적절한 방법이기 때문이다. 컴퓨터 시스템은 사용자의 프로그램을 실행하고, 사용자의 문제를 쉽게 해결해 주기위해 존재한다. 이러한 과정에서 컴퓨터 하드웨어가 제작되고, 순수 하드웨어 만으로는 사용하기 쉽지 않으므로 응용프로그램이 개발되었다. 이후 다양한 응용 프로그램들은 입출력 장치의 통제와 같은 공통적인 연산을 필요로 하게 된다. 여기에 자원을 제어하고 할당하는 공통 기능을 하나의 소프트웨어로 통합한 것이 오늘날의 운영체제이다.

*   초장기 컴퓨터는 암호 깨기와 탄도 계산과 같은 특수 목적 시스템으로 사용되었다. 그러나 이후 컴퓨터는 범용의 다기능 대형컴퓨터로 발전하였고 그즈음 운영체제가 탄생하게 되었다. 컴퓨터의 기능이 확대되고 크기는 작아졌으며, 용도가 다양해 졌고, 그에 맞춰 다양한 운영체제가 생겨났다. 이러한 다양한 운영체제에 대한 완벽한 정의는 존재하지 않는다. 다만 일반적인 정의로 운영체제는 컴퓨터에서 항상 수행되는 프로그램으로 일반적으로 커널이라 불린다. 그러나 오늘날 휴대용 장치의 운영체제를 보면 운영체제를 구성하는 기능의 수가 증가함을 볼 수 있다. 휴대용 운영체제는 종종 핵심 커널외에 미들웨어 ( 응용 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크 집합)을 포함한다. 예를 들어 IOS, 안드로이드는 핵심 커널과 더불어 데이터베이스, 멀티미디어 및 그래픽스를 제공한다.  



## 2. 컴퓨터 시스템의 구성 


## 2.1 컴퓨터 시스템 연산

### 2.1.1 컴퓨터 시스템 구조

*   컴퓨터 시스템은 CPU, 공유 메모리, 장치 제어기, 공통 버스로 구성되어 있다. CPU, 장치 제어기는 공유 메모리에 대한 접근을 제공하는 공통 버스에 의해 연결되어 있다 (하기 그림 참조).

> I/O Interface란 무엇인가?

> 입출력 인터페이스, 입출력 채널, 입출력 프로세서, 입출력 제어기, 장치 제어기등 다양한 이름으로 불린다. 
이러한 인터페이스가 필요한 이유는 주변 장치의 경우 데이터의 형식 및 전송 속도의 차이로 
중앙 처리 장치와 주기억장치와의 직접적인 통신이 불가능하기 때문이다.  

*   각 장치제어기는 특정 장치( 디스크 드라이브, 오디오 장치 등 )을 관리하고 있으며 메모리 사이클을 얻기 위해 CPU와 경쟁하며 병렬 수행된다. 메모리 제어기는 메모리에 대한 접근을 동기화 함으로써 공유 메모리에 대한 질서 있는 접근을 유지한다.  
![현대의 컴퓨터 시스템](https://t1.daumcdn.net/cfile/tistory/2772A041535305A41B)

### 2.1.2 컴퓨터 시스템 구동 과정

*   컴퓨터가 구동을 시작하기 위해서는 수행할 초기 프로그램이 필요하며 이를 부트스트랩 프로그램이라 지칭한다. 부트스트랩 프로그램은 보통 펌웨어라고 알려져 있는 컴퓨터 내의 읽기 전용 메모리나 EEPROM에 저장된다. 이것은 CPU 레지스터로부터, 장치 제어기, 메모리 내용등을 포함한 시스템의 모든 면을 초기화한다. 또한 부트스트랩 프로그램에는 운영체제를 적재하는 방법 및 수행을 시작하는 방법이 포함되어 있다. 따라서 부트스트랩 프로그램은 최종적으로 운영체제의 커널을 찾아 메모리에 적재하게 된다. 

> EEPROM이란?

> EEPROM을 설명하기에 앞서 우선 ROM의 변천 과정에 대해서 알아보겠다. ROM은 Read-only memory의 줄임말로, 말 그대로 읽기만 가능한 메모리라는 뜻이다. 하지만 이건 아주 옛날 이야기고, 최근 생산되는 대부분의 ROM은 적어도 한번 이상은 정보를 수정 가능하게끔 되어있다.

> ROM이 처음 세상에 등장했을 때는 공장에서 제조될때 바로 데이터가 저장되어 고정된 채 생산되었다. 그랬기 때문에 후에 데이터를 변경하는 것이 불가능 했다. 여기서 한발자국 더 나아간 것이 PROM이다. PROM(Programmable ROM)은 이름에서 보다시피 '프로그래밍 가능한' 롬이다. 프로그래밍 가능하다는 것은 내부의 회로를 변경해서 데이터를 수정할 수 있다는 말이다. 그러나 내부의 퓨즈를 끊어서 정보를 저장하는 방식이기 때문에 한번 데이터를 설정하면 그 이후에는 변경하지 못한다. 

>이것을 보완해서 나온 것이 EPROM(Erasable PROM)이다. EPROM은 자외선을 이용해서 정보를 지우며, 여러번 썼다 지웠다 할 수 있다. EPROM을 다시 보완해서 나온 것이 오늘 살펴볼 EEPROM이다. 자외선을 이용해서 정보를 지워야 하는 EPROM과는 다르게 전기적으로 지웠다 썼다 할 수 있기 때문에 쓰는 속도가 매우 빠르고, 전용 롬라이터(롬을 기록할 수 있도록 해주는 장비)가 없어도 손쉽게 다룰 수 있다. 심지어 EEPROM을 RAM의 대용으로 사용하는 경우도 있다. 예를 들어 Atmega328같은 마이컴에는 내부에 약 1kb정도의 EEPROM이 있는데, RAM용량이 부족한 경우 RAM대용으로 상수나 자주 사용하지 않는 변수 등을 여기에 담아서 활용하기도 한다. 물론 RAM보다는 훨씬 느리므로 사용하는데 한계는 있다.

> 출처 : https://kcal2845.tistory.com/37

*   커널이 적재되고 수행이 시작되면 시스템과 사용자에게 서비스를 제공할 수 잇다. 일부 서비스는 커널이 아닌 시스템 프로그램에 의해 제공되며 이들은 부트 시에 메모리에 적재되어 커널이 수행되는 동안 계속 수행되는 시스템 프로세스나 시스템 디먼이 된다. 유닉스에서는 첫 시스템 프로세스가 "init"이며, INIT에 의해 다른 많은 디먼이 시작된다. 이 단계가 끝나면 시스템이 완전히 부트된 상태이며 시스템은 이벤트 발생을 대기하게 된다. 

### 2.1.3 인터럽트(Interrupt)와 시스템 호출(System Call)

*   이벤트가 발생하면 하드웨어나 소프트웨어로부터 발생한 인터럽트에 의해 신호가 보내진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. 소프트웨어는 시스템 콜을 통해 인터럽트를 발생시킬 수 있다. 
*   CPU에 인터럽트가 도착하면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는 일반저긍로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이 실행된다. 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 중단 되었던 연산을 재개한다. 
*   위와 같은 전달을 처리하는 직선적인 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러를 호출한다. 그러나 인터럽트는 매우 빠르게 처리되어야 하고, 사용 가능한 인터럽트의 수가 미리 정의되어 있으므로, 일반적인 루틴 호출 대신 테이블을 통하여 간접적으로 인터럽트 루틴이 호출 될 수 있다. 이러한 테이블에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있으며, 하위 메로리에 저장된다. 이 경우 이터럽트가 요청되면, 인터럽트를 유발한 장치를 우한 인터럽트 서비스 루틴의 주소를 제공하기 위해, 이 주소의 배열 즉, 인터럽트 벡터가 인터럽트 요청과 함께 주어진 고유의 유일한 장치번호로 색인된다. 
*   이터럽트 구조는 중단된 명령의 주소를 반드시 저장해야 된다. 최근 운영체제는 시스템 스택에 복귀 주소를 저장하며, 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요가 있다면, 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다. 인터럽트를 수행하고, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작된다. 

[Interrupt 참고자료](https://slidesplayer.org/slide/14981607/)

## 2.2 저장 장치 구조 
### 2.2.1 저장 장치의 동작 과정 
*   CPU는 명령어를 단지 메모리로부터 가져올 수 있으므로 프로그램을 수행하기 위해서는 반드시 프로그램이 메모리에 적재되어 있어야한다. 범용 컴퓨터는 대부분의 프로그램을 주 메모리라 불리는 재기록 가능한 메모리에서 가져 오며, 이는 DRAM이라 불리는 반도체 기술로 구현된다. 앞서 살펴 보았듯이 EPPROM의 경우 펌웨어를 저장하기위한 용도로 주로 사용되며, 예들 들어 스마트폰은 공장에서 설치한 프로그램을 저장하기 위해 EPPRom을 사용한다.   
*   모든 형태의 메모리는 바이트의 배열을 제공한다. 그리고 각 바이트는 자신의 주소를 가지고 있으며 크게 적재와 저장이 가능하다. 적재 명령은 주 메모리로부터 CPU 내부의 레지스터로 한 바이트 혹은 워드를 옮기는 것이다. 반대로 저장명령은 CPU 레지스터의 내용을 주 메모리로 옮긴다. 
*   폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을 명령 레지스터에 저장한다. 이어서 명령을 해독하고, 이 과정에서 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 이 후 결과가 다시 메모리에 저장될 수 있다. 이상적으로는 프로그램과 데이터가 주 메로리에 영구히 존재하면 좋겠으나 이는 하기 서술할 2가지 이유 때문에 불가하다. 첫 번째로 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다. 두 번째로 주 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 장치이다. 따라서 대부분의 컴퓨터 시스템은 주 메모리의 확장으로 보조 저장 장치를 제공한다. 가장 일반적인 보조 저장 장치로는 프로그램과 데이터를 모두 저장할 수 있는 자기 디스크가 존재한다. 대부분의 프로그램은 메모리에 적재될 때까지 디스크에 저장된다. 

### 2.2.2 저장 장치의 종류 및 특징

*   앞서 기술된 주 메모리 및 자기디스크외에도 다양한 저장장치가 존재하며 이를 하기의 그림처럼 하나의 계층으로서 표시할 수 있다. 
![저장 장치 계층](https://3.bp.blogspot.com/-HJnfPCXn2hs/WLv8yzbggrI/AAAAAAAAAt0/tLiPFBO6cDQhqOa5k_8GaTIIx_iBq3SZACLcB/s1600/010_Memory1.png)

*  상위 계층으로 갈 수록 접근 시간을 단축되나, 가격이 비싸지고 비트 당 비용이 증가한다. 서로 다른 비용과 속도를 갖는 것 외에도 휘발성 혹은 비휘발성의 특징을 가진다. 상기 그림에서 반도체 디스크의 위의 저장 시스템은 휘발성이며, 반면 반도체 디스크 및 그 아래의 장치들은 비휘발성이다. 반도체 디스크의 경우 다수의 종류가 존재하나 일반적으로 자기 디스크보다 빠르며 비휘발성이다. 반도체 디스크의 예시 중 하나는 플래시 메모리이다. 플래시 메모리는 카메라 및 PDA등에 사용되고 있으며 점차 범용 컴퓨터의 저장장치로 영역을 확대하고 있다. 완전한 메모리 시스템의 설계를 위해서는 이러한 요인들 간의 균형을 맞추어야 한다. 즉, 필요한 만큼의 상위 계층의 저장장치를 사용하며, 가능한 많은 비휘발성 메모리를 제공해야한다. 두 구성요소간의 전송률 혹은 시간에 차이가 날 경우 캐시의 도입또한 고려되어야한다. 


## 2.3 입출력 구조 
*   #1에서 잠시 언급하였듯이, 현대의 컴퓨터 시스템은 공통 버스에 의해 연결된 여러 개의 장치 제어기와 CPU로 구성되어 있다. 각 장치 제겅기가 특정 타입의 장치를 담당한다. 개별 장치제어기는 약간의 로컬 버퍼 저장 장치와 특수 목적용 레지스터 집합을 유지한다. 장치 제어기는 자신이 제어하는 주변 장치와 자신의 로컬 버퍼 저장 장치 사이의 데이터 전송을 담당한다. 이 때 장치 제어기에 따라 하나이상의 장치가 부착 될 수 있다. 예를 들어 SCSI 제어기에는 7개 이상의 장치가 부착 될 수 있다. 통상적으로 운영체제는 각 장치 제어기 마다 디바이스 드라이버를 가지고 있으며, 디바이스 드라이버는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분에게 일관된 인터페이스를 제공한다. 

### 2.3.1 입출력 장치의 동작 
*   입출력 연산을 시작하기 위해, 디바이스 드라이버는 장치 제어기의 적절한 리지스터에 필요한 값을 적재한다. 장치 제어기는 동작을 결정하기 위해 레지스터의 내용을 조사한다. 이후 제어기는 장치로 부터 자신의 로컬 버퍼로 데이터 전송을 시작한다. 일단 데이터의 전송이 완료되면, 장치 제어기는 자신이 연산을 완료했음을 인터럽트를 통해 디바이스 드라이버에게 알린다. 그러면 디바이스 드라이버는 제어를 운영체제에게 반환하고 상태에 따라 데이터 혹은 데이터에 대한 포인터를 같이 반환할 수 있다.
*   위와 같은 방식은 많은 양의 데이터를 전송하는 데에는 높은 오버헤드를 초래한다. 이 문제를 해결하기 위해 도입된 기법이 DMA(Direct Memory Access)장치가 사용된다. 장치에 대한 버퍼, 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입없이 메모리로부터 혹은 메모리로 데이터 블록을 전송한다. 한 바이트마다 인터럽트가 발생하는 것이 아닌 블록 전송이 완료될 때 인터럽트가 발생하게 된다. 따라서 CPU는 장치 제어기가 데이터를 전송하는 동안 다른 작업을 수행할 수 있다. 일부 시스테므이 경우 버스 대신에 스위치 구조를 사용한다. 이 경우에는 공유 버스를 사용하기 위한 경쟁이 존재하지 않고, 다수의 구성요소가 서로 동시에 통신하는 것이 가능하다. 이 때 DMA의 사용은 더욱 효과적이다. 

![DMA](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F993AB04A5C8391F5237D04)

## 3. 컴퓨터 시스템 구조 
### 3.1 단일 처리기 시스템
### 3.2 다중 처리기 시스템
### 3.3 클러스터형 시스템

## 4. 운영체제의 구조 
## 5. 운영체제 연산
## 6. 프로세스 관리
## 7. 메모리 관리
## 8. 저장장치 관리
## 9. 보호와 보안
## 10. 커널 자료구조 
## 11. 계산환경
## 12. 오픈소스 운영체제 
